-- [[ SPIN WHEEL SERVER v1.0 - PROBABILIDAD Y ANTI-EXPLOIT ]]
-- UBICACIÓN: ServerScriptService -> Script

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local ServerScriptService = game:GetService("ServerScriptService")

-- Configuración
local Config = require(ServerScriptService:WaitForChild("GameConfig"))
local CUBE_TYPES = Config.CUBES
local SPIN_COOLDOWN = 60 -- Segundos entre giros (ajustable)

-- Definición de Premios (Debe sumar 100%)
local LOOT_TABLE = {
	{Type = "Cube", Name = "Madera", Chance = 50, Angle = 0},    -- 50%
	{Type = "Cash", Name = "$5,000", Amount = 5000, Chance = 30, Angle = 72}, -- 30%
	{Type = "Cube", Name = "Oro", Chance = 15, Angle = 144},     -- 15%
	{Type = "Cube", Name = "TITANIO", Chance = 4, Angle = 216},  -- 4%
	{Type = "Cube", Name = "Glitch", Chance = 1, Angle = 288}    -- 1%
}

-- Setup Remotes
local Remotes = ReplicatedStorage:FindFirstChild("ViralRemotes") or Instance.new("Folder", ReplicatedStorage)
local spinFunc = Remotes:FindFirstChild("SpinWheel") or Instance.new("RemoteFunction", Remotes)
spinFunc.Name = "SpinWheel"

local cooldowns = {}

-- Función auxiliar para buscar datos del cubo en GameConfig
local function GetCubeData(name)
	for _, c in ipairs(CUBE_TYPES) do
		if c.Name == name then return c end
	end
	return nil
end

-- Lógica Principal
spinFunc.OnServerInvoke = function(player)
	-- 1. Anti-Exploit: Cooldown
	local lastSpin = cooldowns[player.UserId] or 0
	if os.time() - lastSpin < SPIN_COOLDOWN then
		return false, "¡Espera " .. (SPIN_COOLDOWN - (os.time() - lastSpin)) .. "s!"
	end
	cooldowns[player.UserId] = os.time()
	player:SetAttribute("NextSpinTime", os.time() + SPIN_COOLDOWN)
	-- 2. Matemáticas de Probabilidad (Weighted Random)
	local roll = math.random(1, 100)
	local cumulative = 0
	local prize = nil

	for _, entry in ipairs(LOOT_TABLE) do
		cumulative += entry.Chance
		if roll <= cumulative then
			prize = entry
			break
		end
	end

	if not prize then prize = LOOT_TABLE[1] end -- Fallback

	-- 3. Entregar Premio
	-- (Se entrega ANTES de la animación visual para evitar lag, 
	-- pero visualmente el cliente lo celebra después)

	if prize.Type == "Cash" then
		player.leaderstats.Cash.Value += prize.Amount
		print("Ruleta: " .. player.Name .. " ganó $" .. prize.Amount)

	elseif prize.Type == "Cube" then
		local data = GetCubeData(prize.Name)
		if data then
			-- Crear Cubo
			local cube = Instance.new("Part")
			cube.Name = data.Name
			cube.Size = Vector3.new(4,4,4)
			cube.Position = player.Character.HumanoidRootPart.Position + Vector3.new(0, 10, 0)
			cube.Material = data.Mat
			cube.Color = data.Color
			cube:SetAttribute("Value", data.Value)
			cube:SetAttribute("Price", data.Price)
			cube:SetAttribute("Owner", player.UserId)

			-- Lógica Especial Glitch
			if prize.Name == "Glitch" then
				task.spawn(function()
					while cube and cube.Parent do
						cube:SetAttribute("Value", math.random(-100, 500))
						task.wait(10)
					end
				end)
			end

			-- Intentar guardar en Inventario (Mochila)
			local inv = player:FindFirstChild("Inventory")
			local maxSlots = player:GetAttribute("MaxSlots") or 4

			if inv and #inv:GetChildren() < maxSlots then
				-- A la mochila
				cube.CanCollide = false
				cube.Anchored = true
				cube.Transparency = 1
				cube.CFrame = CFrame.new(0, -500, 0)
				cube.Parent = inv
			else
				-- Al suelo (Workspace)
				cube.CanCollide = true
				cube.Anchored = false
				cube.Parent = workspace.GlobalCubes
			end
		end
	end

	-- 4. Retornar ángulo objetivo al cliente para la animación
	return true, prize.Angle, prize.Name
end

-- [[ VIRAL TYCOON - GAME MANAGER v38.0 (EL C√ìDIGO DE DIOS) ]]
-- UBICACI√ìN: ServerScriptService -> Script

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")
local DataStoreService = game:GetService("DataStoreService")
local Debris = game:GetService("Debris")
local ServerScriptService = game:GetService("ServerScriptService")
local PhysicsService = game:GetService("PhysicsService")

-- === IMPORTAR CONFIGURACI√ìN ===
local ConfigModule = ServerScriptService:WaitForChild("GameConfig")
local Config = require(ConfigModule)

local SETTINGS = Config.SETTINGS
local CUBE_TYPES = Config.CUBES

-- DATASTORE (CAMBIAMOS LA VERSI√ìN PARA EVITAR CONFLICTOS VIEJOS)
local ViralDataStore = DataStoreService:GetDataStore("ViralData_v38_Final") 

-- === VARIABLES GLOBALES ===
local plots = {}
local towersFolder = workspace:FindFirstChild("Towers") or Instance.new("Folder", workspace)
towersFolder.Name = "Towers"
local globalCubes = workspace:FindFirstChild("GlobalCubes") or Instance.new("Folder", workspace)
globalCubes.Name = "GlobalCubes"
-- [[ AGREGAR ESTO EN TUS VARIABLES GLOBALES ]]
local Teams = game:GetService("Teams") 
local altarsFolder = workspace:FindFirstChild("Altars") or Instance.new("Folder", workspace)
altarsFolder.Name = "Altars"

pcall(function()
	PhysicsService:RegisterCollisionGroup("Player")
	PhysicsService:RegisterCollisionGroup("CarriedCube")
	PhysicsService:CollisionGroupSetCollidable("Player", "CarriedCube", false)
end)

-- MERCADO DE VALORES
local MarketMultipliers = {}
local MarketNews = ReplicatedStorage:FindFirstChild("MarketNews") or Instance.new("StringValue", ReplicatedStorage)
MarketNews.Name = "MarketNews"
MarketNews.Value = "Mercado estable."
-- Inicializar
for _, data in ipairs(CUBE_TYPES) do MarketMultipliers[data.Name] = 1.0 end

-- === SETUP RED (REMOTES) ===
local Remotes = ReplicatedStorage:FindFirstChild("ViralRemotes") or Instance.new("Folder", ReplicatedStorage)
Remotes.Name = "ViralRemotes"

local placeEvent = Remotes:FindFirstChild("PlaceCube") or Instance.new("RemoteEvent", Remotes)
placeEvent.Name = "PlaceCube"
local eventMessage = Remotes:FindFirstChild("EventMessage") or Instance.new("RemoteEvent", Remotes)
eventMessage.Name = "EventMessage"
local upgradeInvEvent = Remotes:FindFirstChild("UpgradeInventory") or Instance.new("RemoteFunction", Remotes)
upgradeInvEvent.Name = "UpgradeInventory"
local equipInvEvent = Remotes:FindFirstChild("EquipFromInventory") or Instance.new("RemoteEvent", Remotes)
equipInvEvent.Name = "EquipFromInventory"
local unstuckEvent = Remotes:FindFirstChild("Unstuck") or Instance.new("RemoteEvent", Remotes)
unstuckEvent.Name = "Unstuck"
local requestPickupEvent = Remotes:FindFirstChild("RequestPickupCube") or Instance.new("RemoteEvent", Remotes)
requestPickupEvent.Name = "RequestPickupCube"
local storeInBackpackEvent = Remotes:FindFirstChild("StoreInBackpack") or Instance.new("RemoteEvent", Remotes)
storeInBackpackEvent.Name = "StoreInBackpack"
local requestMoveEvent = Remotes:FindFirstChild("RequestMoveCube") or Instance.new("RemoteEvent", Remotes)
requestMoveEvent.Name = "RequestMoveCube"
local requestStealEvent = Remotes:FindFirstChild("RequestStealCube") or Instance.new("RemoteEvent", Remotes)
requestStealEvent.Name = "RequestStealCube"

-- ==========================================================
-- 1. SISTEMA DE PERSISTENCIA (GUARDADO Y CARGA)
-- ==========================================================

-- [[ REEMPLAZO BLOQUE 4: SavePlayerData (FIX APEX SAVING) ]]
local function SavePlayerData(player)
	local userId = player.UserId
	local tycoon = towersFolder:FindFirstChild("Tycoon_"..userId)
	if not tycoon then return end

	local data = {
		Cash = player.leaderstats.Cash.Value,
		MaxSlots = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS,
		Permablocks = {}
	}

	local origin = tycoon.GridParts.Origin.Position
	for _, b in ipairs(tycoon.Blocks:GetChildren()) do
		-- VALIDACI√ìN ESTRICTA: Debe tener IsPerma Y NO LLAMARSE APEX
		if b:GetAttribute("IsPerma") == true and b.Name ~= "APEX" then
			local relPos = b.Position - origin
			table.insert(data.Permablocks, {Pos = {relPos.X, relPos.Y, relPos.Z}, Type = b.Name})
		end
	end

	local success, err = pcall(function()
		ViralDataStore:SetAsync("Player_"..userId, data)
	end)
	if not success then warn("Error guardando datos de "..player.Name..": "..err) end
end

-- [[ REEMPLAZO BLOQUE: LoadPlayerData (FIX ERROR BLOCKS NIL) ]]
-- [[ REEMPLAZO BLOQUE: LoadPlayerData (FIX GRAVEDAD AL INICIO) ]]
local function LoadPlayerData(player)
	local userId = player.UserId
	local success, data = pcall(function() return ViralDataStore:GetAsync("Player_"..userId) end)

	if success and data then
		player.leaderstats.Cash.Value = data.Cash or 1200
		player:SetAttribute("MaxSlots", data.MaxSlots or SETTINGS.BASE_SLOTS)

		task.spawn(function()
			local tycoon = nil
			repeat task.wait(0.5) tycoon = towersFolder:FindFirstChild("Tycoon_"..userId) until tycoon

			local blocksFolder = tycoon:FindFirstChild("Blocks")
			if not blocksFolder then blocksFolder = Instance.new("Folder", tycoon); blocksFolder.Name = "Blocks" end

			local origin = tycoon.GridParts.Origin.Position

			if data.Permablocks then
				for _, pData in ipairs(data.Permablocks) do
					local pos = Vector3.new(pData.Pos[1], pData.Pos[2], pData.Pos[3]) + origin
					local foundData = nil
					for _, c in ipairs(CUBE_TYPES) do if c.Name == pData.Type then foundData = c break end end

					if foundData then
						local cube = Instance.new("Part"); cube.Name = foundData.Name; cube.Size = Vector3.new(4,4,4)
						cube.Position = pos; cube.Material = foundData.Mat; cube.Color = foundData.Color
						cube.Parent = blocksFolder 

						-- [[ L√ìGICA DE CA√çDA INICIAL ]]
						-- Si la altura relativa es menor a 3 (est√° tocando el suelo), ANCLARLO como cimiento.
						-- Si est√° m√°s alto (es torre), DESANCLARLO para que la gravedad lo tire.
						if pData.Pos[2] < 3.0 then
							cube.Anchored = true
						else
							cube.Anchored = false -- ¬°AQUI EST√Å LA MAGIA! Se caer√°n al cargar.
						end

						cube:SetAttribute("Owner", userId)
						cube:SetAttribute("Value", foundData.Value)
						cube:SetAttribute("IsPerma", true)

						-- Visuales (legibles como el resto de cubos)
						local sg = Instance.new("SurfaceGui", cube); sg.Face = Enum.NormalId.Front; sg.PixelsPerStud = 128
						local t = Instance.new("TextLabel", sg); t.Size = UDim2.new(1,0,1,0); t.Text = foundData.Rarity.."\n"..foundData.Name
						t.TextScaled = false; t.TextSize = 42; t.BackgroundTransparency = 1; t.TextColor3 = Color3.new(1,1,1); t.Font = Enum.Font.FredokaOne; t.TextWrapped = true
						-- MOVER se usa desde el HUD (RequestMoveCube), no ProximityPrompt en el cubo
					end
				end
			end
		end)
	else
		player:SetAttribute("MaxSlots", SETTINGS.BASE_SLOTS)
	end
end


-- ==========================================================
-- 2. MONETIZACI√ìN Y EXTRAS (JETPACK, UPGRADES)
-- ==========================================================

function GiveJetpack(player)
	local success, hasPass = pcall(function() 
		return MarketplaceService:UserOwnsGamePassAsync(player.UserId, SETTINGS.GAMEPASS_JETPACK_ID) 
	end)
	if hasPass then
		local tool = Instance.new("Tool"); tool.Name = "Jetpack"; tool.RequiresHandle = true
		local handle = Instance.new("Part", tool); handle.Name = "Handle"; handle.Size = Vector3.new(2,2,1); handle.Color = Color3.new(1,0.5,0); handle.Material = Enum.Material.Neon

		local localScript = Instance.new("LocalScript", tool)
		localScript.Source = [[
			local tool = script.Parent
			local player = game.Players.LocalPlayer
			local char = player.Character or player.CharacterAdded:Wait()
			local hrp = char:WaitForChild("HumanoidRootPart")
			local UIS = game:GetService("UserInputService")
			local rs = game:GetService("RunService")
			local bv = Instance.new("BodyVelocity"); bv.MaxForce = Vector3.new(0,0,0); bv.Parent = hrp
			local flying = false; local fuel = 100
			
			tool.Equipped:Connect(function()
				UIS.InputBegan:Connect(function(i,g) if not g and i.KeyCode==Enum.KeyCode.Space then flying=true end end)
				UIS.InputEnded:Connect(function(i) if i.KeyCode==Enum.KeyCode.Space then flying=false end end)
				rs.RenderStepped:Connect(function()
					if flying and fuel > 0 then
						bv.MaxForce = Vector3.new(0, 50000, 0); bv.Velocity = Vector3.new(0, 50, 0); fuel -= 0.5
					else
						bv.MaxForce = Vector3.new(0,0,0); if fuel < 100 then fuel += 0.1 end
					end
				end)
			end)
			tool.Unequipped:Connect(function() flying = false; bv.MaxForce = Vector3.new(0,0,0) end)
		]]
		tool.Parent = player.Backpack
	end
end

-- UPGRADE MOCHILA (REMOTE FUNCTION)
upgradeInvEvent.OnServerInvoke = function(player)
	local currentSlots = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS

	-- FASE 1: CASH (Hasta 16)
	if currentSlots < SETTINGS.CASH_SLOT_LIMIT then
		local cost = 1000 * (currentSlots ^ 2)
		if player.leaderstats.Cash.Value >= cost then
			player.leaderstats.Cash.Value -= cost
			local newSlots = currentSlots + 4
			player:SetAttribute("MaxSlots", newSlots)
			return true, "¬°Mochila mejorada a " .. newSlots .. " slots!"
		else
			return false, "Necesitas $" .. cost .. " para mejorar."
		end
		-- FASE 2: ROBUX (Hasta 32)
	elseif currentSlots < SETTINGS.MAX_TOTAL_SLOTS then
		MarketplaceService:PromptProductPurchase(player, SETTINGS.DEV_PRODUCT_SLOTS_ID)
		return true, "Abriendo mercado de Robux..."
	else
		return false, "¬°Mochila al M√ÅXIMO nivel!"
	end
end

-- PROCESS RECEIPT (COMPRAS REALES)
MarketplaceService.ProcessReceipt = function(receiptInfo)
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end

	-- COMPRA DE SLOTS
	if receiptInfo.ProductId == SETTINGS.DEV_PRODUCT_SLOTS_ID then
		local current = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS
		if current < SETTINGS.MAX_TOTAL_SLOTS then
			player:SetAttribute("MaxSlots", current + 4)
			eventMessage:FireClient(player, "üíé ¬°Espacio aumentado con Robux!")
			return Enum.ProductPurchaseDecision.PurchaseGranted
		end
	end

	-- COMPRA DE PERMABLOCK
	if receiptInfo.ProductId == SETTINGS.DEV_PRODUCT_PERMABLOCK_ID then
		local tycoon = towersFolder:FindFirstChild("Tycoon_"..player.UserId)
		if tycoon then
			local data = {Name = "Permablock", Value = 200, Price = 0, Rarity = "ETERNO", Color = Color3.new(1,1,1), Mat = Enum.Material.Neon}
			-- Crear cubo y forzarlo a la mano
			local cube = Instance.new("Part"); cube.Name = data.Name; cube.Size = Vector3.new(4,4,4)
			cube.Material = data.Mat; cube.Color = data.Color
			cube:SetAttribute("Owner", player.UserId); cube:SetAttribute("Value", 200); cube:SetAttribute("IsPerma", true)

			-- Pickup forzado usando la misma l√≥gica que el resto
			cube.Parent = workspace
			PickupCube(player, cube, 200)

			return Enum.ProductPurchaseDecision.PurchaseGranted
		end
	end

	return Enum.ProductPurchaseDecision.NotProcessedYet
end

-- ==========================================================
-- 3. L√ìGICA DE INVENTARIO Y RECOGIDA
-- ==========================================================
-- [[ PEGAR EN SECCI√ìN DE FUNCIONES ]]

function SetupTeamsAndAltars()
	-- Crear Teams en Roblox si no existen
	if not Teams:FindFirstChild("Azul") then
		local t = Instance.new("Team", Teams); t.Name = "Azul"; t.TeamColor = BrickColor.new("Bright blue"); t.AutoAssignable = false
	end
	if not Teams:FindFirstChild("Rojo") then
		local t = Instance.new("Team", Teams); t.Name = "Rojo"; t.TeamColor = BrickColor.new("Bright red"); t.AutoAssignable = false
	end

	-- Generar Altares F√≠sicos
	if SETTINGS.TEAMS then
		for teamKey, info in pairs(SETTINGS.TEAMS) do
			local altarName = "Altar_" .. teamKey
			if not altarsFolder:FindFirstChild(altarName) then
				local altar = Instance.new("Model", altarsFolder); altar.Name = altarName

				-- Base
				local base = Instance.new("Part", altar); base.Name = "Base"; base.Anchored = true
				base.Size = Vector3.new(SETTINGS.ALTAR_RADIUS * 2, 1, SETTINGS.ALTAR_RADIUS * 2)
				base.Position = info.AltarPos; base.Color = info.Color; base.Material = Enum.Material.Neon; base.Shape = Enum.PartType.Cylinder
				base.CFrame = CFrame.new(info.AltarPos) * CFrame.Angles(0,0,math.rad(90)) 

				-- Zona Visual
				local zone = Instance.new("Part", altar); zone.Name = "ZoneDisplay"; zone.Anchored = true; zone.CanCollide = false
				zone.Size = Vector3.new(SETTINGS.ALTAR_RADIUS * 2, 50, SETTINGS.ALTAR_RADIUS * 2)
				zone.Position = info.AltarPos + Vector3.new(0, 25, 0); zone.Shape = Enum.PartType.Cylinder
				zone.CFrame = CFrame.new(zone.Position) * CFrame.Angles(0,0,math.rad(90))
				zone.Color = info.Color; zone.Transparency = 0.8; zone.Material = Enum.Material.ForceField

				-- Carpeta interna
				local blocks = Instance.new("Folder", altar); blocks.Name = "Blocks"

				-- Cartel Flotante
				local bb = Instance.new("Part", altar); bb.Size=Vector3.new(1,1,1); bb.Anchored=true; bb.Transparency=1; bb.Position=info.AltarPos+Vector3.new(0,20,0)
				local bg = Instance.new("BillboardGui", bb); bg.Size=UDim2.new(0,200,0,100); bg.AlwaysOnTop=true
				local tl = Instance.new("TextLabel", bg); tl.Size=UDim2.new(1,0,1,0); tl.Text="FONDO COM√öN\n"..info.Name; tl.TextColor3=info.Color; tl.BackgroundTransparency=1; tl.TextScaled=true; tl.Font=Enum.Font.FredokaOne
			end
		end
	end
end

function AssignTeam(player)
	local blues = #Teams.Azul:GetPlayers()
	local reds = #Teams.Rojo:GetPlayers()
	if blues <= reds then
		player.Team = Teams.Azul; player.TeamColor = BrickColor.new("Bright blue")
	else
		player.Team = Teams.Rojo; player.TeamColor = BrickColor.new("Bright red")
	end
end
-- [[ REEMPLAZO DE PickupCube (FIX VUELO) ]]
-- [[ REEMPLAZAR FUNCI√ìN PickupCube ]]
-- [[ REEMPLAZO BLOQUE 1: PickupCube ]]
-- [[ REEMPLAZO BLOQUE 2: PickupCube (FIX RECYCLER TEXT) ]]
-- [[ REEMPLAZO BLOQUE: PickupCube (FIX VOLAR/CAER) ]]
function PickupCube(player, cube, val)
	if not cube or not cube.Parent then return false end

	-- Si ya llevas un cubo en la mano no puedes recoger otro (hay que soltar o guardar en mochila)
	if player:GetAttribute("Carrying") then 
		eventMessage:FireClient(player, "‚ùå Suelta o guarda el cubo en la mochila primero.")
		return false
	end

	-- B. MANO (FIX F√çSICA AGRESIVA)
	player:SetAttribute("Carrying", true)
	player:SetAttribute("CarryingValue", val)

	-- 1. DESACTIVAR F√çSICA ANTES DE MOVER
	cube.Anchored = false
	cube.CanCollide = false
	cube.Massless = true 
	cube.CustomPhysicalProperties = nil -- BORRAR DENSIDAD (Esto arregla el caerse al piso)
	cube.CollisionGroup = "CarriedCube" 

	-- Resetear velocidades para evitar tirones y empujones raros
	if cube:IsA("BasePart") then
		cube.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
		cube.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
	end

	-- 2. POSICIONAR Y SOLDAR (orden cr√≠tico: posici√≥n primero, weld despu√©s)
	local hrp = player.Character.HumanoidRootPart
	cube.Parent = player.Character

	-- Limpiar welds viejos antes de posicionar
	for _, w in ipairs(cube:GetChildren()) do
		if w:IsA("WeldConstraint") or w:IsA("Weld") then w:Destroy() end
	end

	-- Posici√≥n en manos: delante del pecho, altura de brazos (en espacio del personaje)
	local offset = CFrame.new(0, 1.2, -2.2)
	cube.CFrame = hrp.CFrame * offset

	-- Usar Weld cl√°sico con C0/C1 para que el offset quede fijo y no se pierda con red/f√≠sica
	local weld = Instance.new("Weld", cube)
	weld.Name = "CarryingWeld"
	weld.Part0 = hrp
	weld.Part1 = cube
	weld.C0 = offset
	weld.C1 = CFrame.new(0, 0, 0)
	weld.Parent = cube

	-- Desactivar Prompt
	local p = cube:FindFirstChild("ProximityPrompt"); if p then p.Enabled = false end

	-- Actualizar Texto Recycler
	local myTycoon = towersFolder:FindFirstChild("Tycoon_"..player.UserId)
	if myTycoon and myTycoon:FindFirstChild("Recycler") then
		local rp = myTycoon.Recycler:FindFirstChild("ProximityPrompt")
		if rp then rp.ActionText = "VENDER ($"..math.floor(val*0.5)..")" end
	end

	-- Limpieza si explota
	local con; con = cube.AncestryChanged:Connect(function(_, parent)
		if not parent then 
			player:SetAttribute("Carrying", false)
			-- Restaurar Recycler
			if myTycoon and myTycoon:FindFirstChild("Recycler") then
				local rp = myTycoon.Recycler:FindFirstChild("ProximityPrompt")
				if rp then rp.ActionText = "RECICLAR" end
			end
			if con then con:Disconnect() end 
		end
	end)
	return true
end


-- Sacar item de mochila (slotIndex 1-based). Si ya llevas cubo, se intercambia.
equipInvEvent.OnServerEvent:Connect(function(player, slotIndex)
	local inv = player:FindFirstChild("Inventory")
	if not inv then return end
	local items = inv:GetChildren()
	if #items == 0 then return end

	local idx = (type(slotIndex) == "number" and slotIndex > 0 and slotIndex <= #items) and slotIndex or #items
	local cube = items[idx]
	if not cube or not cube:IsA("BasePart") then return end

	-- Si ya llevas un cubo, guardarlo en la mochila primero (intercambio)
	if player:GetAttribute("Carrying") then
		local maxSlots = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS
		if #items >= maxSlots then
			eventMessage:FireClient(player, "‚ùå ¬°Mochila llena! Suelta el cubo primero.")
			return
		end
		local carriedCube = nil
		for _, c in ipairs(player.Character:GetChildren()) do
			if c:FindFirstChild("CarryingWeld") then carriedCube = c; break end
		end
		if carriedCube then
			local weld = carriedCube:FindFirstChild("CarryingWeld")
			if weld then weld:Destroy() end
			player:SetAttribute("Carrying", false)
			carriedCube.CanCollide = false
			carriedCube.Anchored = true
			carriedCube.Transparency = 1
			carriedCube.CFrame = CFrame.new(0, -500, 0)
			carriedCube.Parent = inv
			carriedCube:SetAttribute("Owner", player.UserId)
		end
	end

	cube.Transparency = 0
	cube.Anchored = false
	local ok = PickupCube(player, cube, cube:GetAttribute("Value"))
	if ok then
		eventMessage:FireClient(player, "üîº Equipado: " .. cube.Name)
	end
end)

-- Recoger/Comprar cubo desde HUD (sin ProximityPrompt en el cubo)
requestPickupEvent.OnServerEvent:Connect(function(player, cubePosition)
	if player:GetAttribute("Carrying") then return end
	local char = player.Character
	if not char or not cubePosition then return end
	local ref = cubePosition and (typeof(cubePosition) == "Vector3") and cubePosition or char.HumanoidRootPart.Position
	local bestCube, bestDist = nil, 14
	for _, c in ipairs(globalCubes:GetChildren()) do
		if c:IsA("BasePart") and c:GetAttribute("Value") ~= nil then
			local d = (c.Position - ref).Magnitude
			if d < bestDist then bestCube = c; bestDist = d end
		end
	end
	if not bestCube then return end
	local owner = bestCube:GetAttribute("Owner") or 0
	local price = bestCube:GetAttribute("Price") or 0
	local cost = (owner == player.UserId) and 0 or (owner == 0 and price or price * 3)
	if not player.leaderstats or player.leaderstats.Cash.Value < cost then return end
	local val = bestCube:GetAttribute("Value") or 0
	local ok = PickupCube(player, bestCube, val)
	if ok then
		if cost > 0 then player.leaderstats.Cash.Value -= cost end
		bestCube:SetAttribute("Owner", player.UserId)
		local p = bestCube:FindFirstChild("ProximityPrompt")
		if p then p.Enabled = false end
	end
end)

-- Buscar cubo cerca de una posici√≥n (GlobalCubes, Towers, Altars)
local function findCubeNearPosition(refPos, maxDist)
	maxDist = maxDist or 12
	for _, c in ipairs(globalCubes:GetChildren()) do
		if c:IsA("BasePart") and c:GetAttribute("Value") ~= nil then
			if (c.Position - refPos).Magnitude <= maxDist then return c end
		end
	end
	local towers = workspace:FindFirstChild("Towers")
	if towers then
		for _, tycoon in ipairs(towers:GetChildren()) do
			local blocks = tycoon:FindFirstChild("Blocks")
			if blocks then
				for _, c in ipairs(blocks:GetChildren()) do
					if c:IsA("BasePart") and (c.Position - refPos).Magnitude <= maxDist then return c end
				end
			end
		end
	end
	for _, altar in ipairs(altarsFolder:GetChildren()) do
		local blocks = altar:FindFirstChild("Blocks")
		if blocks then
			for _, c in ipairs(blocks:GetChildren()) do
				if c:IsA("BasePart") and (c.Position - refPos).Magnitude <= maxDist then return c end
			end
		end
	end
	return nil
end

-- MOVER: recoger mi cubo (en torre/altar) sin pagar
requestMoveEvent.OnServerEvent:Connect(function(player, cubePosition)
	if player:GetAttribute("Carrying") then return end
	local char = player.Character
	if not char or not cubePosition or typeof(cubePosition) ~= "Vector3" then return end
	local cube = findCubeNearPosition(cubePosition, 14)
	if not cube then return end
	local owner = cube:GetAttribute("Owner") or 0
	if owner ~= player.UserId then return end
	local val = cube:GetAttribute("Value") or 0
	local ok = PickupCube(player, cube, val)
	if ok then eventMessage:FireClient(player, "üîº Movido: " .. cube.Name) end
end)

-- ROBAR: pagar 3x precio y quedarse con el cubo de otro
requestStealEvent.OnServerEvent:Connect(function(player, cubePosition)
	if player:GetAttribute("Carrying") then return end
	local char = player.Character
	if not char or not cubePosition or typeof(cubePosition) ~= "Vector3" then return end
	local cube = findCubeNearPosition(cubePosition, 14)
	if not cube then return end
	local owner = cube:GetAttribute("Owner") or 0
	if owner == player.UserId then return end
	if cube:GetAttribute("IsPerma") then return end
	local price = cube:GetAttribute("Price") or 100
	local stealCost = price * 3
	if not player.leaderstats or player.leaderstats.Cash.Value < stealCost then
		eventMessage:FireClient(player, "‚ùå Necesitas $" .. stealCost .. " para robar.")
		return
	end
	player.leaderstats.Cash.Value -= stealCost
	local stealP = cube:FindFirstChild("StealPrompt")
	if stealP then stealP:Destroy() end
	for _, w in ipairs(cube:GetChildren()) do if w:IsA("WeldConstraint") or w:IsA("Weld") then w:Destroy() end end
	cube.Anchored = false
	cube:SetAttribute("Owner", player.UserId)
	cube:SetAttribute("TeamOwner", nil)
	local val = cube:GetAttribute("Value") or 0
	PickupCube(player, cube, val)
	eventMessage:FireClient(player, "üí∞ Robado: " .. cube.Name)
end)

-- Guardar cubo de la mano en la mochila
storeInBackpackEvent.OnServerEvent:Connect(function(player)
	if not player:GetAttribute("Carrying") then return end
	local inv = player:FindFirstChild("Inventory")
	local maxSlots = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS
	if not inv or #inv:GetChildren() >= maxSlots then
		eventMessage:FireClient(player, "‚ùå ¬°Mochila llena!")
		return
	end
	local carriedCube = nil
	for _, c in ipairs(player.Character:GetChildren()) do
		if c:FindFirstChild("CarryingWeld") then carriedCube = c; break end
	end
	if not carriedCube then return end
	local weld = carriedCube:FindFirstChild("CarryingWeld")
	if weld then weld:Destroy() end
	player:SetAttribute("Carrying", false)
	carriedCube.CanCollide = false
	carriedCube.Anchored = true
	carriedCube.Transparency = 1
	carriedCube.CFrame = CFrame.new(0, -500, 0)
	carriedCube.Parent = inv
	carriedCube:SetAttribute("Owner", player.UserId)
	eventMessage:FireClient(player, "üéí Guardado: " .. carriedCube.Name)
end)

-- Bot√≥n "desatascar": teleporta al jugador al lado del letrero de su base
unstuckEvent.OnServerEvent:Connect(function(player)
	if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
	local tycoon = towersFolder:FindFirstChild("Tycoon_"..player.UserId)
	if not tycoon then return end

	local board = tycoon:FindFirstChild("Board")
	if not board then return end

	local hrp = player.Character.HumanoidRootPart
	-- Posici√≥n segura: unos studs delante del letrero y un poco elevada
	local forward = board.CFrame.LookVector
	local targetPos = board.Position + forward * -8 + Vector3.new(0, 5, 0)

	hrp.CFrame = CFrame.new(targetPos, targetPos + forward)
end)

-- ==========================================================
-- 4. SPAWN DE CUBOS Y MEC√ÅNICAS (SPYBOX, GLITCH...)
-- ==========================================================

-- [[ REEMPLAZAR FUNCI√ìN CreateStealPrompt ]]
function CreateStealPrompt(cube)
	-- Si ya tiene prompt o es Permablock, no hacer nada
	if cube:FindFirstChild("StealPrompt") or cube:GetAttribute("IsPerma") then return end

	local price = cube:GetAttribute("Price") or 100
	local stealCost = price * 3

	local p = Instance.new("ProximityPrompt", cube)
	p.Name = "StealPrompt"
	p.ActionText = "ROBAR ($".. stealCost ..")"
	p.HoldDuration = 2
	p.Enabled = false -- Se usa desde el HUD (RequestStealCube), no el prompt en el cubo

	p.Triggered:Connect(function(interactor)
		-- Verificar que NO sea el due√±o (El due√±o usa Recoger normal si quiere)
		if interactor.UserId == cube:GetAttribute("Owner") then return end

		if interactor.leaderstats.Cash.Value >= stealCost then
			interactor.leaderstats.Cash.Value -= stealCost
			p:Destroy() -- Quitar prompt

			-- Liberar cubo f√≠sicamente (quitar weld de agarre, sea Weld o WeldConstraint)
			for _, w in ipairs(cube:GetChildren()) do if w:IsA("WeldConstraint") or w:IsA("Weld") then w:Destroy() end end
			cube.Anchored = false

			-- CAMBIAR DUE√ëO AL LADR√ìN
			cube:SetAttribute("Owner", interactor.UserId)
			cube:SetAttribute("TeamOwner", nil) -- Deja de ser del equipo anterior

			-- MANDAR AL INVENTARIO/MANO DEL LADR√ìN
			PickupCube(interactor, cube, cube:GetAttribute("Value"))
			print(interactor.Name .. " rob√≥ un cubo!")
		end
	end)
end

-- [[ REEMPLAZO BLOQUE 1: SpawnCube (FIX VISUALES + OFFSET) ]]
function SpawnCube(customData)
	if #globalCubes:GetChildren() >= 100 then return end
	local data = customData or CUBE_TYPES[math.random(1, #CUBE_TYPES)]
	if not customData and data.Name == "Permablock" then return end
	local cube = Instance.new("Part"); cube.Name = data.Name; cube.Size = Vector3.new(4,4,4)
	if data.Name == "Jab√≥n" then 
		cube.Shape = Enum.PartType.Ball
		cube.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0, 0.5, 100, 1) 
	end

	cube.Position = Vector3.new(math.random(-60, 60), 120, math.random(-60, 60))
	cube.Material, cube.Color = data.Mat, data.Color
	cube:SetAttribute("Owner", 0); cube:SetAttribute("Value", data.Value); cube:SetAttribute("Price", data.Price)
	if data.Name == "Permablock" then cube:SetAttribute("IsPerma", true) end

	cube.Parent = globalCubes -- IMPORTANTE: Parentar antes de loops

	-- MEC√ÅNICA GLITCH
	if data.Name == "Glitch" then
		task.spawn(function()
			while cube and cube.Parent do
				cube:SetAttribute("Value", math.random(-100, 500))
				task.wait(10)
			end
		end)
	end
	-- MEC√ÅNICA ANTIMATERIA
	if data.Name == "Antimateria" then
		cube.Touched:Connect(function(hit)
			if hit:IsA("BasePart") and hit ~= cube then
				if hit:GetAttribute("IsPerma") then return end
				local isOtherCube = hit:GetAttribute("Value") ~= nil or (hit.Parent and (hit.Parent.Name == "Blocks" or hit.Parent.Name == "GlobalCubes"))
				if isOtherCube then
					local exp = Instance.new("Explosion"); exp.Position = cube.Position; exp.BlastRadius = 6; exp.Parent = workspace
					hit:Destroy(); cube:Destroy()
				end
			end
		end)
	end

	-- ETIQUETAS VISUALES: alta resoluci√≥n para que se lea bien; cada cara usa todo el espacio
	local function makeTxt(f, txt, col, useScaled)
		local sg = Instance.new("SurfaceGui", cube)
		sg.Face = f
		sg.PixelsPerStud = 128
		sg.ClipsDescendants = false
		local l = Instance.new("TextLabel", sg)
		l.Size = UDim2.new(1, 0, 1, 0)
		l.Text = txt
		l.TextColor3 = col
		l.BackgroundTransparency = 1
		l.Font = Enum.Font.FredokaOne
		l.TextScaled = (useScaled == true)
		if not useScaled then l.TextSize = 42 end
		l.TextWrapped = true
		return l
	end
	-- Cara frontal: Rarity + Nombre bien legibles (texto fijo grande)
	makeTxt(Enum.NormalId.Front, data.Rarity .. "\n" .. data.Name, Color3.new(1, 1, 1), false)

	-- Cara superior: $/s ocupa toda la cara
	local valLabel = makeTxt(Enum.NormalId.Top, "", Color3.new(0,1,0), true)
	task.spawn(function()
		while cube and cube.Parent do
			local currentVal = cube:GetAttribute("Value") or 0
			valLabel.Text = (currentVal >= 0 and "+$" or "$") .. currentVal .. "/s"
			valLabel.TextColor3 = currentVal >= 0 and Color3.new(0,1,0) or Color3.new(1,0,0)
			task.wait(1)
		end
	end)

	-- Cara derecha: timer o due√±o ocupa toda la cara
	local infoLabel = makeTxt(Enum.NormalId.Right, "...", Color3.new(1,1,0), true)
	task.spawn(function()
		local timeLeft = SETTINGS.CUBE_LIFETIME
		while cube and cube.Parent do
			local ownerId = cube:GetAttribute("Owner") or 0
			if ownerId ~= 0 then
				local p = Players:GetPlayerByUserId(ownerId)
				infoLabel.Text = p and p.Name or "VENDIDO"
				infoLabel.TextColor3 = Color3.new(0,1,0)
			else
				infoLabel.Text = timeLeft .. "s"
				infoLabel.TextColor3 = Color3.new(1,1,0)
				timeLeft -= 1
				if timeLeft <= 0 then cube:Destroy(); break end
			end
			task.wait(1)
		end
	end)

	-- Sin ProximityPrompt aqu√≠: recoger/comprar se hace desde el HUD (tecla E) v√≠a RequestPickupCube
	return cube
end

-- ==========================================================
-- 5. EVENTO PRINCIPAL: COLOCAR CUBOS (PLACE)
-- ==========================================================

-- [[ REEMPLAZO BLOQUE 3: PlaceCube (FIX F√çSICA + ALTAR) ]]
-- [[ REEMPLAZO BLOQUE 2: PlaceEvent (FIX F√çSICA Y ROBO) ]]
placeEvent.OnServerEvent:Connect(function(player, hitPos)
	local char = player.Character; if not char then return end
	local carriedCube = nil
	for _, c in ipairs(char:GetChildren()) do if c:FindFirstChild("CarryingWeld") then carriedCube = c; break end end

	if not carriedCube then -- Sacar de mochila
		local inv = player:FindFirstChild("Inventory")
		if inv and #inv:GetChildren() > 0 then
			local items = inv:GetChildren(); local cube = items[#items]
			cube.Transparency=0; cube.Anchored=false
			PickupCube(player, cube, cube:GetAttribute("Value"))
			carriedCube = cube
		else return end
	end

	-- Guardar la posici√≥n actual del cubo antes de soltarlo.
	-- Esto permite que el clic solo sea "disparador" y no cambie
	-- la posici√≥n: se soltar√° donde lo est√°s sujetando.
	local dropPos = carriedCube.Position

	-- Soltar y Restaurar F√≠sica
	local weld = carriedCube:FindFirstChild("CarryingWeld"); if weld then weld:Destroy() end
	player:SetAttribute("Carrying", false)
	carriedCube.Massless = false; carriedCube.CanCollide = true; carriedCube.CollisionGroup = "Default"

	-- Restaurar texto Recycler
	local myTycoon = towersFolder:FindFirstChild("Tycoon_"..player.UserId)
	if myTycoon and myTycoon:FindFirstChild("Recycler") then
		local rp = myTycoon.Recycler:FindFirstChild("ProximityPrompt")
		if rp then rp.ActionText = "RECICLAR" end
	end

	-- MOVER/ROBAR se usan desde el HUD; no mostramos ProximityPrompt en el cubo
	local isPerma = carriedCube:GetAttribute("IsPerma")
	local p = carriedCube:FindFirstChild("ProximityPrompt")
	if p then p.Enabled = false end
	if not isPerma then CreateStealPrompt(carriedCube) end

	-- A. ALTAR CHECK (usando la posici√≥n donde realmente est√° el cubo)
	for _, altar in ipairs(altarsFolder:GetChildren()) do
		local base = altar:FindFirstChild("Base")
		if base and (Vector2.new(dropPos.X, dropPos.Z) - Vector2.new(base.Position.X, base.Position.Z)).Magnitude < (SETTINGS.ALTAR_RADIUS + 5) then 
			carriedCube.Position = Vector3.new(dropPos.X, dropPos.Y+2, dropPos.Z)
			carriedCube.Anchored = false 
			carriedCube.Parent = altar.Blocks

			local tName = string.match(altar.Name, "Altar_(.+)"); local finalTeam = (tName == "BLUE") and "Azul" or "Rojo"
			carriedCube:SetAttribute("TeamOwner", finalTeam)
			if player.Team.Name ~= finalTeam and not isPerma then CreateStealPrompt(carriedCube) end
			return
		end
	end

	-- B. TOWER CHECK (tambi√©n basado en la posici√≥n real del cubo)
	local targetPlot = nil
	for _, pm in ipairs(towersFolder:GetChildren()) do
		local op = pm.GridParts.Origin
		if (Vector2.new(dropPos.X, dropPos.Z) - Vector2.new(op.Position.X, op.Position.Z)).Magnitude < 160 then targetPlot = pm; break end
	end

	if targetPlot then
		local origin = targetPlot.GridParts.Origin.Position
		local gx, gz = math.round((dropPos.X-origin.X)/4)*4 + origin.X, math.round((dropPos.Z-origin.Z)/4)*4 + origin.Z
		local ray = workspace:Raycast(Vector3.new(gx, 500, gz), Vector3.new(0, -500, 0))

		if ray then 
			-- Si clicaste sobre otro cubo de la torre, apilar exactamente encima.
			local hitPart = ray.Instance
			if hitPart and hitPart:IsDescendantOf(targetPlot) and hitPart ~= carriedCube then
				local topY = hitPart.Position.Y + (hitPart.Size.Y / 2)
				local ownHalf = carriedCube.Size.Y / 2
				carriedCube.Position = Vector3.new(hitPart.Position.X, topY + ownHalf + 0.05, hitPart.Position.Z)
			else
				-- Caso general: usar el snap de grilla como antes.
				carriedCube.Position = Vector3.new(gx, ray.Position.Y + 2.1, gz)
			end
			carriedCube.Parent = targetPlot.Blocks

			-- [[ FIX F√çSICA: Gravedad afecta a TODOS (Incluso Eternos) ]]
			if ray.Instance.Name == "Origin" then 
				carriedCube.Anchored = true 
			else 
				carriedCube.Anchored = false 
			end

			-- Solo permitir robo si NO es Perma y NO soy el due√±o de la base
			if targetPlot:GetAttribute("OwnerID") ~= player.UserId and not isPerma then 
				CreateStealPrompt(carriedCube) 
			end
		else 
			carriedCube.Position=Vector3.new(gx,4,gz); carriedCube.Parent=globalCubes; carriedCube.Anchored=false 
		end
	else 
		carriedCube.CFrame = char.HumanoidRootPart.CFrame * CFrame.new(0,0,-5); carriedCube.Parent=globalCubes; carriedCube.Anchored=false 
	end
end)

-- ==========================================================
-- 6. BASES, ANDAMIOS Y SETUP
-- ==========================================================
-- [[ INSERTAR TABLONES FALTANTES ]]
function CreateLB(name, pos, title, color)
	if workspace:FindFirstChild("LB_"..name) then return workspace["LB_"..name].SurfaceGui.ScrollingFrame end
	local p = Instance.new("Part", workspace); p.Name = "LB_"..name; p.Size = Vector3.new(20, 30, 2); p.Anchored = true; p.Position = pos; p.Color = Color3.fromRGB(20, 20, 20); p.Material = Enum.Material.Metal
	local sg = Instance.new("SurfaceGui", p); sg.Face = Enum.NormalId.Front; sg.CanvasSize = Vector2.new(800, 1000)
	local f = Instance.new("ScrollingFrame", sg); f.Size = UDim2.new(1,0,1,0); f.BackgroundTransparency = 1; f.ScrollBarThickness = 0
	local h = Instance.new("TextLabel", f); h.Size = UDim2.new(1,0,0,120); h.Text = title; h.TextScaled = true; h.TextColor3 = color; h.BackgroundTransparency = 1; h.Font = Enum.Font.FredokaOne
	return f
end
local lbCash = CreateLB("Cash", Vector3.new(0, 30, 320), "üí∞ MILLONARIOS üí∞", Color3.fromRGB(0, 255, 100))
local lbHeight = CreateLB("Height", Vector3.new(40, 30, 320), "üèóÔ∏è RASCACIELOS üèóÔ∏è", Color3.fromRGB(255, 170, 0))
local lbTime = CreateLB("Time", Vector3.new(-40, 30, 320), "‚è≥ VICIOSOS ‚è≥", Color3.fromRGB(0, 150, 255))

function UpdateLBs()
	local function render(f, func, fmt)
		local d = {}
		for _, p in ipairs(Players:GetPlayers()) do local v=func(p); if v and v>0 then table.insert(d,{N=p.Name, V=v}) end end
		table.sort(d, function(a,b) return a.V > b.V end)
		for _, c in ipairs(f:GetChildren()) do if c:IsA("TextLabel") and c.Name ~= "Title" then c:Destroy() end end
		for i, e in ipairs(d) do if i>15 then break end
			local t = Instance.new("TextLabel", f); t.Size = UDim2.new(1,0,0,60); t.Position = UDim2.new(0,0,0,120+(i*60)); t.BackgroundTransparency=1; t.Text=i..". "..e.N..": "..fmt(e.V); t.TextColor3=Color3.new(1,1,1); t.TextScaled=true; t.Font=Enum.Font.Code
		end
	end
	pcall(function()
		render(lbCash, function(p) return p.leaderstats.Cash.Value end, function(v) return "$"..math.floor(v) end)
		render(lbHeight, function(p) return p.leaderstats.Height.Value end, function(v) return math.floor(v).."m" end)
		render(lbTime, function(p) return p:GetAttribute("Time") end, function(v) return math.floor(v/60).."m" end)
	end)
end
-- [[ REEMPLAZAR FUNCI√ìN SetupPlots COMPLETA ]]
-- [[ REEMPLAZO DE SetupPlots (FIX VISUALES + ANDAMIOS) ]]
function SetupPlots()
	local angleStep = (math.pi * 2) / SETTINGS.MAX_PLAYERS
	for i = 1, SETTINGS.MAX_PLAYERS do
		local angle = (i-1) * angleStep
		local pos = Vector3.new(math.sin(angle) * SETTINGS.CENTER_DIST, 1, math.cos(angle) * SETTINGS.CENTER_DIST)

		local m = Instance.new("Model", towersFolder); m.Name = "Plot_"..i
		m:SetAttribute("OwnerID", 0); m:SetAttribute("Expansions", 0)
		local gp = Instance.new("Folder", m); gp.Name = "GridParts"

		-- BASE E ICONOS
		local base = Instance.new("Part", gp); base.Name = "Origin"; base.Size = Vector3.new(32,1,32)
		base.Position = pos; base.Anchored = true; base.Material = Enum.Material.DiamondPlate
		base.Color = Color3.fromRGB(50, 50, 50) -- Se pintar√° al entrar el jugador
		base.CFrame = CFrame.lookAt(pos, Vector3.new(0, 1, 0))

		local board = Instance.new("Part", m); board.Size = Vector3.new(18,12,1); board.Anchored = true; board.Name = "Board"; board.Color = Color3.new(0,0,0)

		-- Icono Flotante
		local iconPart = Instance.new("Part", m); iconPart.Name = "IconAnchor"; iconPart.Transparency = 1; iconPart.Anchored = true; iconPart.CanCollide = false
		local bb = Instance.new("BillboardGui", iconPart); bb.Size = UDim2.new(0, 200, 0, 100); bb.AlwaysOnTop = true; bb.StudsOffset = Vector3.new(0, 2, 0)
		local lbl = Instance.new("TextLabel", bb); lbl.Size = UDim2.new(1,0,1,0); lbl.BackgroundTransparency = 1
		lbl.Text = "LIBRE"; lbl.TextColor3 = Color3.new(1,1,1); lbl.TextStrokeTransparency = 0; lbl.Font = Enum.Font.FredokaOne; lbl.TextScaled = true; lbl.Name = "IconLabel"

		-- Botones
		local btnExpand = Instance.new("Part", m); btnExpand.Name = "ExpandButton"; btnExpand.Size = Vector3.new(8, 1, 8); btnExpand.Anchored = true; btnExpand.Color = Color3.fromRGB(0, 150, 255); btnExpand.Material = Enum.Material.Neon
		local rec = Instance.new("Part", m); rec.Name = "Recycler"; rec.Size = Vector3.new(12, 0.5, 12); rec.Anchored = true; rec.Color = Color3.fromRGB(255, 0, 0); rec.Material = Enum.Material.Neon

		-- Configuraci√≥n Andamios
		local scaffoldConfig = {
			{Name="Right", Dir=base.CFrame.RightVector, Color=Color3.fromRGB(255, 200, 0)},
			{Name="Left",  Dir=-base.CFrame.RightVector, Color=Color3.fromRGB(255, 150, 0)},
			{Name="Back",  Dir=-base.CFrame.LookVector,  Color=Color3.fromRGB(200, 100, 0)}
		}

		-- Crear Botones Andamios
		for _, sc in ipairs(scaffoldConfig) do
			m:SetAttribute("ScaffoldH_"..sc.Name, 0)
			local sBtn = Instance.new("Part", m); sBtn.Name = "ScaffoldBtn_"..sc.Name; sBtn.Size = Vector3.new(4, 1, 4); sBtn.Anchored = true; sBtn.Color = sc.Color; sBtn.Material = Enum.Material.Neon
			-- Prompt Andamio
			local sp = Instance.new("ProximityPrompt", sBtn); sp.ActionText = "ANDAMIO "..string.upper(sc.Name).." ($"..SETTINGS.SCAFFOLD_COST..")"; sp.HoldDuration = 1
			sp.Triggered:Connect(function(plr)
				if plr.UserId == m:GetAttribute("OwnerID") and plr.leaderstats.Cash.Value >= SETTINGS.SCAFFOLD_COST then
					plr.leaderstats.Cash.Value -= SETTINGS.SCAFFOLD_COST
					local key = "ScaffoldH_"..sc.Name; local currentH = m:GetAttribute(key)
					local scaffold = Instance.new("TrussPart", m); scaffold.Name = "Scaffold_"..sc.Name; scaffold.Size = Vector3.new(2, 24, 2); scaffold.Anchored = true; scaffold.Color = Color3.new(0.5,0.5,0.5)
					scaffold.Position = base.Position + (sc.Dir * (base.Size.X/2 + 1)) + Vector3.new(0, 12 + currentH, 0); m:SetAttribute(key, currentH + 24)
				end
			end)
		end

		-- Funci√≥n Update Local
		local function updateAssets()
			board.CFrame = base.CFrame * CFrame.new(0, 10, (base.Size.Z/2) + 8)
			btnExpand.CFrame = base.CFrame * CFrame.new(0, 0, (base.Size.Z/2) + 16)
			rec.CFrame = base.CFrame * CFrame.new(-(base.Size.X/2 + 10), 0, 0)
			iconPart.Position = base.Position + Vector3.new(0, 30, 0)
			for _, sc in ipairs(scaffoldConfig) do
				local sBtn = m:FindFirstChild("ScaffoldBtn_"..sc.Name)
				if sBtn then sBtn.Position = base.Position + (sc.Dir * (base.Size.X/2 + 6)) end
			end
		end
		updateAssets() -- Ejecutar al inicio

		plots[i] = {Model = m, Base = base, IconLabel = lbl, Owner = nil}

		-- Prompts Base
		local bp = Instance.new("ProximityPrompt", btnExpand); bp.ActionText = "EXPANDIR ($"..SETTINGS.BASE_EXPAND_COST..")"
		bp.Triggered:Connect(function(plr)
			local count = m:GetAttribute("Expansions")
			if plr.UserId == m:GetAttribute("OwnerID") and count < SETTINGS.MAX_EXPANSIONS and plr.leaderstats.Cash.Value >= SETTINGS.BASE_EXPAND_COST then
				plr.leaderstats.Cash.Value -= SETTINGS.BASE_EXPAND_COST
				m:SetAttribute("Expansions", count + 1); base.Size += Vector3.new(8, 0, 8); updateAssets()
				if count + 1 >= SETTINGS.MAX_EXPANSIONS then bp.Enabled = false; btnExpand.Transparency = 0.5 end
			end
		end)

		local rp = Instance.new("ProximityPrompt", rec); rp.ActionText = "RECICLAR"; rp.HoldDuration = 0.5
		rp.Triggered:Connect(function(plr)
			if plr.UserId == m:GetAttribute("OwnerID") then
				for _, c in ipairs(plr.Character:GetChildren()) do if c:FindFirstChild("CarryingWeld") then 
						local v=c:GetAttribute("Value") or 0; plr.leaderstats.Cash.Value += math.max(0, math.floor(v*0.5)); c:Destroy(); plr:SetAttribute("Carrying", false); break 
					end end
			end
		end)

		for _, f in ipairs({Enum.NormalId.Front, Enum.NormalId.Back}) do local sg = Instance.new("SurfaceGui", board); sg.Face = f; local t = Instance.new("TextLabel", sg); t.Size = UDim2.new(1,0,1,0); t.Text = "DISPONIBLE"; t.TextScaled = true; t.TextColor3 = Color3.new(1,1,1); t.BackgroundTransparency = 1; t.Font = Enum.Font.FredokaOne end
	end
end

-- ==========================================================
-- 7. LOOPS MAESTROS (ECONOM√çA, MERCADO, EVENTOS)
-- ==========================================================

-- LOOP ECONOM√çA
-- [[ REEMPLAZO BLOQUE: Econom√≠a Loop (FIX TEAM INCOME HUD) ]]
task.spawn(function()
	while true do
		task.wait(SETTINGS.PAY_INTERVAL)

		-- 1. CALCULAR INGRESOS DE EQUIPO (ALTARES)
		-- Los altares se llaman "Altar_BLUE"/"Altar_RED" (Config.SETTINGS.TEAMS),
		-- pero los equipos en Roblox son "Azul"/"Rojo". Aqu√≠ hacemos el mapeo.
		local teamIncome = {Azul = 0, Rojo = 0}

		for _, altar in ipairs(altarsFolder:GetChildren()) do
			local altarKey = string.gsub(altar.Name, "Altar_", "") -- "BLUE" o "RED"
			local teamName
			if altarKey == "BLUE" then
				teamName = "Azul"
			elseif altarKey == "RED" then
				teamName = "Rojo"
			end

			if teamName and altar:FindFirstChild("Blocks") then 
				for _, b in ipairs(altar.Blocks:GetChildren()) do 
					-- Verificar que sea un bloque v√°lido y tenga valor
					if b:IsA("BasePart") then
						local val = b:GetAttribute("Value") or 0
						local mult = MarketMultipliers[b.Name] or 1.0
						teamIncome[teamName] += (val * mult)
					end
				end 
			end
		end

		-- 2. PAGAR A JUGADORES
		for _, p in ipairs(Players:GetPlayers()) do
			local total = 0
			local myTeamIncome = 0

			-- A. Calcular Ingreso Personal (Torre)
			local t = towersFolder:FindFirstChild("Tycoon_"..p.UserId)
			local maxH = 0

			if t then
				local org = t.GridParts.Origin.Position
				local blks = t:FindFirstChild("Blocks")
				if blks then
					for _, b in ipairs(blks:GetChildren()) do
						if b and b:IsA("BasePart") then
							-- Distancia < 240 studs del centro
							if (Vector2.new(b.Position.X, b.Position.Z) - Vector2.new(org.X, org.Z)).Magnitude < 240 then
								local val = b:GetAttribute("Value") or 0
								local mult = MarketMultipliers[b.Name] or 1.0
								total += (val * mult)

								local h = b.Position.Y - org.Y; if h > maxH then maxH = h end
							else 
								-- Ca√≠da
								b.Parent = globalCubes; b.Anchored = false 
							end
						end
					end
				end
				-- Bono de Altura
				local hMult = 1 + (math.floor(maxH/4)*0.5)
				total = total * hMult

				-- Actualizar Stat Altura
				if p.leaderstats:FindFirstChild("Height") then p.leaderstats.Height.Value = math.floor(maxH) end
			end

			-- B. Calcular Reparto de Equipo
			if p.Team then 
				local tName = p.Team.Name -- "Azul" o "Rojo"
				local totalTeamMoney = teamIncome[tName] or 0
				local members = #p.Team:GetPlayers()

				if members > 0 then 
					myTeamIncome = totalTeamMoney / members 
				end

				-- ACTUALIZAR HUD TEAM INCOME (Aqu√≠ estaba el fallo)
				if p.leaderstats:FindFirstChild("TeamIncome") then 
					p.leaderstats.TeamIncome.Value = "+$" .. math.floor(myTeamIncome) .. "/s" 
				end

				-- Actualizar Pizarra de Base
				if t and t:FindFirstChild("Board") then
					t.Board.SurfaceGui.TextLabel.Text = string.format("%s\n$%.0f/s\n(TEAM: +$%.0f)", p.Name, total, myTeamIncome)
				end
			else
				-- Sin equipo
				if p.leaderstats:FindFirstChild("TeamIncome") then p.leaderstats.TeamIncome.Value = "$0/s" end
			end

			-- PAGO FINAL
			local finalPay = total + myTeamIncome
			p.leaderstats.Cash.Value = math.max(0, p.leaderstats.Cash.Value + finalPay)
			p:SetAttribute("Time", (p:GetAttribute("Time") or 0) + 1)
		end

		if UpdateLBs then UpdateLBs() end
	end
end)

-- LOOP MERCADO (STONKS)
task.spawn(function()
	while true do
		task.wait(60) -- 60s
		local targetData = CUBE_TYPES[math.random(1, #CUBE_TYPES)]; local targetName = targetData.Name
		local rawMult = math.random(5, 30) / 10 -- 0.5x a 3.0x

		for k, _ in pairs(MarketMultipliers) do MarketMultipliers[k] = 1.0 end -- Reset
		MarketMultipliers[targetName] = rawMult

		local status = (rawMult > 1) and "üìà STONKS ‚¨ÜÔ∏è" or (rawMult < 1 and "üìâ STONKS ‚¨áÔ∏è" or "Estable")
		local msg = string.format("%s: %s x%.1f", status, targetName, rawMult)
		MarketNews.Value = msg; eventMessage:FireAllClients(msg)
	end
end)

-- LOOP EVENTOS
task.spawn(function()
	local chaosTimer, celestialTimer, stormTimer = 0, 0, 0
	while true do
		task.wait(1); chaosTimer += 1; celestialTimer += 1; stormTimer += 1

		if chaosTimer >= SETTINGS.CHAOS_INTERVAL then 
			chaosTimer = 0; local e = math.random(1,3)
			if e == 1 then eventMessage:FireAllClients("‚ö† ¬°FALLO GRAVEDAD! ‚ö†"); workspace.Gravity = 30; task.wait(45); workspace.Gravity = 196.2
			elseif e == 2 then eventMessage:FireAllClients("‚ö† ¬°SPEED RUN! ‚ö†"); for _,p in ipairs(Players:GetPlayers()) do if p.Character then p.Character.Humanoid.WalkSpeed = 80 end end; task.wait(30); for _,p in ipairs(Players:GetPlayers()) do if p.Character then p.Character.Humanoid.WalkSpeed = SETTINGS.PLAYER_SPEED end end
			elseif e == 3 then eventMessage:FireAllClients("‚ö† ¬°EL JUICIO DEL YUNQUE! ‚ö†"); task.wait(4); local rich, maxC = nil, -1; for _,p in ipairs(Players:GetPlayers()) do if p.leaderstats.Cash.Value > maxC then maxC = p.leaderstats.Cash.Value; rich = p end end; if rich and rich.Character then local anvil = Instance.new("Part"); anvil.Size = Vector3.new(12,10,12); anvil.Color = Color3.new(0,0,0); anvil.Position = rich.Character.HumanoidRootPart.Position + Vector3.new(0,100,0); anvil.CustomPhysicalProperties = PhysicalProperties.new(100, 0, 0, 100, 100); anvil.Parent = workspace; Debris:AddItem(anvil, 20) end
			end
		end

		if celestialTimer >= (SETTINGS.CELESTIAL_INTERVAL - 20) then
			celestialTimer = 0; local top, maxH = nil, -1
			for _,p in ipairs(Players:GetPlayers()) do local h = p:GetAttribute("MaxH") or 0; if h > maxH then maxH = h; top = p end end
			if top and maxH > 0 then
				if top.Character then local ff = Instance.new("ForceField", top.Character); Debris:AddItem(ff, 60) end
				eventMessage:FireAllClients("‚ú® TRIBUTO PARA "..top.Name.." ‚ú®")
				local t = towersFolder:FindFirstChild("Tycoon_"..top.UserId)
				if t then local ac = SpawnCube({Name="APEX", Value=1000, Price=0, Rarity="GOD", Color=Color3.new(1,1,1), Mat=Enum.Material.Neon}); ac.Anchored=true; ac.Position = t.GridParts.Origin.Position + Vector3.new(0, maxH+10, 0); ac.Parent = t.Blocks end
			end
		end

		if stormTimer >= 900 then
			stormTimer = 0; local topGlobalCube, topGlobalY = nil, -1e9
			for _, tycoon in ipairs(towersFolder:GetChildren()) do
				local blks = tycoon:FindFirstChild("Blocks")
				if blks then
					for _, b in ipairs(blks:GetChildren()) do
						if b:IsA("Part") and b.Position.Y > topGlobalY and (b.Material == Enum.Material.Metal or b.Material == Enum.Material.DiamondPlate) then topGlobalY = b.Position.Y; topGlobalCube = b end
					end
				end
			end
			if topGlobalCube then
				local msg = Instance.new("Message", workspace); msg.Text = "‚ö° RAYO DE ZEUS ‚ö°"; Debris:AddItem(msg, 10)
				local beam = Instance.new("Part", workspace); beam.Size = Vector3.new(2, 500, 2); beam.Position = topGlobalCube.Position + Vector3.new(0, 250, 0); beam.Anchored = true; beam.CanCollide = false; beam.Color = Color3.new(1,1,1); beam.Material = Enum.Material.Neon; Debris:AddItem(beam, 0.5)
				topGlobalCube:SetAttribute("Value", (topGlobalCube:GetAttribute("Value") or 0) * 8); topGlobalCube.Color = Color3.fromRGB(0, 255, 255)
			end
		end
	end
end)

-- ==========================================================
-- 8. INICIALIZACI√ìN Y PLAYER LIFECYCLE (CORREGIDO)
-- ==========================================================
SetupTeamsAndAltars()
SetupPlots()

-- Funci√≥n encargada de preparar al jugador (Datos, Base, Personaje)
local function OnPlayerJoin(p)
	-- Evitar reinicializar si ya carg√≥
	if p:FindFirstChild("leaderstats") then return end

	-- 1. Crear Stats
	local ls = Instance.new("Folder", p); ls.Name = "leaderstats"
	local c = Instance.new("NumberValue", ls); c.Name = "Cash"; c.Value = 1200
	local h = Instance.new("IntValue", ls); h.Name = "Height"; h.Value = 0
	local ti = Instance.new("StringValue", ls); ti.Name = "TeamIncome"; ti.Value = "$0/s"
	local inv = Instance.new("Folder", p); inv.Name = "Inventory"

	-- Atributos Iniciales
	p:SetAttribute("MaxSlots", SETTINGS.BASE_SLOTS)
	p:SetAttribute("Carrying", false)
	p:SetAttribute("Time", 0)
	p:SetAttribute("MaxH", 0)

	-- 2. Cargar Datos y Equipo
	LoadPlayerData(p)
	AssignTeam(p)

	-- 3. ASIGNAR BASE Y ACTUALIZAR TEXTO (FIX "LIBRE")
	for _, plot in ipairs(plots) do 
		if not plot.Owner then 
			plot.Owner = p
			plot.Model.Name = "Tycoon_"..p.UserId
			plot.Model:SetAttribute("OwnerID", p.UserId)

			-- Actualizar Visuales de la Base
			if p.Team then 
				plot.Base.Color = p.Team.TeamColor.Color
				plot.IconLabel.TextColor3 = p.Team.TeamColor.Color 
			end
			plot.IconLabel.Text = "BASE DE\n" .. string.upper(p.Name) -- ¬°Aqu√≠ se quita el LIBRE!
			break 
		end 
	end

	-- 4. Setup del Personaje
	p.CharacterAdded:Connect(function(char)
		task.wait(0.5)
		local hum = char:WaitForChild("Humanoid")
		local hrp = char:WaitForChild("HumanoidRootPart")

		hum.WalkSpeed = SETTINGS.PLAYER_SPEED
		GiveJetpack(p)

		-- L√≥gica de Placaje (Tackle)
		hrp.Touched:Connect(function(hit)
			local ePlr = Players:GetPlayerFromCharacter(hit.Parent)
			if ePlr and ePlr ~= p and hrp.AssemblyLinearVelocity.Magnitude > SETTINGS.TACKLE_SPEED_THRESHOLD and ePlr:GetAttribute("Carrying") then
				local cc = nil
				for _,c in ipairs(hit.Parent:GetChildren()) do if c:FindFirstChild("CarryingWeld") then cc = c; break end end

				if cc and not cc:GetAttribute("IsPerma") then
					-- Soltar cubo enemigo
					cc:FindFirstChild("CarryingWeld"):Destroy()
					ePlr:SetAttribute("Carrying", false)
					cc.CanCollide = true
					cc.Anchored = false
					cc.Parent = globalCubes
					-- Empuj√≥n f√≠sico
					cc:ApplyImpulse((hit.Parent.HumanoidRootPart.Position-hrp.Position).Unit*1500+Vector3.new(0,800,0))
				end
			end
		end)
	end)

end

-- CONECTAR EVENTO
Players.PlayerAdded:Connect(OnPlayerJoin)

-- [[ FIX CR√çTICO: CARGAR JUGADORES EXISTENTES ]]
-- Esto arregla que te salga "LIBRE" cuando pruebas en Studio
for _, p in ipairs(Players:GetPlayers()) do 
	OnPlayerJoin(p) 
end

-- Guardado al salir
Players.PlayerRemoving:Connect(function(p) SavePlayerData(p) end)
game:BindToClose(function() for _, p in ipairs(Players:GetPlayers()) do SavePlayerData(p) end end)


-- Loop Spawn
task.spawn(function() while true do task.wait(1.5) SpawnCube() end end)

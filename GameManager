-- [[ VIRAL TYCOON - GAME MANAGER v38.0 (EL C√ìDIGO DE DIOS) ]]
-- UBICACI√ìN: ServerScriptService -> Script

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local MarketplaceService = game:GetService("MarketplaceService")
local DataStoreService = game:GetService("DataStoreService")
local Debris = game:GetService("Debris")
local ServerScriptService = game:GetService("ServerScriptService")

-- === IMPORTAR CONFIGURACI√ìN ===
local ConfigModule = ServerScriptService:WaitForChild("GameConfig")
local Config = require(ConfigModule)

local SETTINGS = Config.SETTINGS
local CUBE_TYPES = Config.CUBES

-- DATASTORE (CAMBIAMOS LA VERSI√ìN PARA EVITAR CONFLICTOS VIEJOS)
local ViralDataStore = DataStoreService:GetDataStore("ViralData_v38_Final") 

-- === VARIABLES GLOBALES ===
local plots = {}
local towersFolder = workspace:FindFirstChild("Towers") or Instance.new("Folder", workspace)
towersFolder.Name = "Towers"
local globalCubes = workspace:FindFirstChild("GlobalCubes") or Instance.new("Folder", workspace)
globalCubes.Name = "GlobalCubes"

-- MERCADO DE VALORES
local MarketMultipliers = {}
local MarketNews = ReplicatedStorage:FindFirstChild("MarketNews") or Instance.new("StringValue", ReplicatedStorage)
MarketNews.Name = "MarketNews"
MarketNews.Value = "Mercado estable."
-- Inicializar
for _, data in ipairs(CUBE_TYPES) do MarketMultipliers[data.Name] = 1.0 end

-- === SETUP RED (REMOTES) ===
local Remotes = ReplicatedStorage:FindFirstChild("ViralRemotes") or Instance.new("Folder", ReplicatedStorage)
Remotes.Name = "ViralRemotes"

local placeEvent = Remotes:FindFirstChild("PlaceCube") or Instance.new("RemoteEvent", Remotes)
placeEvent.Name = "PlaceCube"
local eventMessage = Remotes:FindFirstChild("EventMessage") or Instance.new("RemoteEvent", Remotes)
eventMessage.Name = "EventMessage"
local upgradeInvEvent = Remotes:FindFirstChild("UpgradeInventory") or Instance.new("RemoteFunction", Remotes)
upgradeInvEvent.Name = "UpgradeInventory"
local equipInvEvent = Remotes:FindFirstChild("EquipFromInventory") or Instance.new("RemoteEvent", Remotes)
equipInvEvent.Name = "EquipFromInventory"

-- ==========================================================
-- 1. SISTEMA DE PERSISTENCIA (GUARDADO Y CARGA)
-- ==========================================================

local function SavePlayerData(player)
	local userId = player.UserId
	local tycoon = towersFolder:FindFirstChild("Tycoon_"..userId)
	if not tycoon then return end
	
	local data = {
		Cash = player.leaderstats.Cash.Value,
		MaxSlots = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS,
		Permablocks = {}
	}
	
	-- Guardamos posici√≥n de Permablocks
	local origin = tycoon.GridParts.Origin.Position
	for _, b in ipairs(tycoon.Blocks:GetChildren()) do
		if b:GetAttribute("IsPerma") then
			local relPos = b.Position - origin
			table.insert(data.Permablocks, {
				Pos = {relPos.X, relPos.Y, relPos.Z},
				Type = b.Name
			})
		end
	end
	
	local success, err = pcall(function()
		ViralDataStore:SetAsync("Player_"..userId, data)
	end)
	if not success then warn("Error guardando datos de "..player.Name..": "..err) end
end

local function LoadPlayerData(player)
	local userId = player.UserId
	local success, data = pcall(function()
		return ViralDataStore:GetAsync("Player_"..userId)
	end)
	
	if success and data then
		player.leaderstats.Cash.Value = data.Cash or 1200
		player:SetAttribute("MaxSlots", data.MaxSlots or SETTINGS.BASE_SLOTS)
		
		-- Reconstruir Permablocks
		task.spawn(function()
			local tycoon = nil
			repeat task.wait(0.5) tycoon = towersFolder:FindFirstChild("Tycoon_"..userId) until tycoon
			
			local origin = tycoon.GridParts.Origin.Position
			if data.Permablocks then
				for _, pData in ipairs(data.Permablocks) do
					local pos = Vector3.new(pData.Pos[1], pData.Pos[2], pData.Pos[3]) + origin
					-- Buscar config del cubo
					local foundData = nil
					for _, c in ipairs(CUBE_TYPES) do if c.Name == pData.Type then foundData = c break end end
					
					if foundData then
						local cube = Instance.new("Part"); cube.Name = foundData.Name; cube.Size = Vector3.new(4,4,4)
						cube.Position = pos; cube.Material = foundData.Mat; cube.Color = foundData.Color
						cube.Anchored = true; cube.Parent = tycoon.Blocks
						cube:SetAttribute("Owner", userId)
						cube:SetAttribute("Value", foundData.Value)
						cube:SetAttribute("Price", foundData.Price)
						cube:SetAttribute("IsPerma", true)
						
						-- Crear etiqueta visual simple
						local sg = Instance.new("SurfaceGui", cube); sg.Face = Enum.NormalId.Front
						local t = Instance.new("TextLabel", sg); t.Size = UDim2.new(1,0,1,0); t.Text = foundData.Rarity.."\n"..foundData.Name; t.TextScaled = true; t.BackgroundTransparency = 1; t.TextColor3 = Color3.new(1,1,1); t.Font = Enum.Font.FredokaOne
					end
				end
			end
		end)
	else
		-- Datos por defecto
		player:SetAttribute("MaxSlots", SETTINGS.BASE_SLOTS)
	end
end

-- ==========================================================
-- 2. MONETIZACI√ìN Y EXTRAS (JETPACK, UPGRADES)
-- ==========================================================

function GiveJetpack(player)
	local success, hasPass = pcall(function() 
		return MarketplaceService:UserOwnsGamePassAsync(player.UserId, SETTINGS.GAMEPASS_JETPACK_ID) 
	end)
	if hasPass then
		local tool = Instance.new("Tool"); tool.Name = "Jetpack"; tool.RequiresHandle = true
		local handle = Instance.new("Part", tool); handle.Name = "Handle"; handle.Size = Vector3.new(2,2,1); handle.Color = Color3.new(1,0.5,0); handle.Material = Enum.Material.Neon
		
		local localScript = Instance.new("LocalScript", tool)
		localScript.Source = [[
			local tool = script.Parent
			local player = game.Players.LocalPlayer
			local char = player.Character or player.CharacterAdded:Wait()
			local hrp = char:WaitForChild("HumanoidRootPart")
			local UIS = game:GetService("UserInputService")
			local rs = game:GetService("RunService")
			local bv = Instance.new("BodyVelocity"); bv.MaxForce = Vector3.new(0,0,0); bv.Parent = hrp
			local flying = false; local fuel = 100
			
			tool.Equipped:Connect(function()
				UIS.InputBegan:Connect(function(i,g) if not g and i.KeyCode==Enum.KeyCode.Space then flying=true end end)
				UIS.InputEnded:Connect(function(i) if i.KeyCode==Enum.KeyCode.Space then flying=false end end)
				rs.RenderStepped:Connect(function()
					if flying and fuel > 0 then
						bv.MaxForce = Vector3.new(0, 50000, 0); bv.Velocity = Vector3.new(0, 50, 0); fuel -= 0.5
					else
						bv.MaxForce = Vector3.new(0,0,0); if fuel < 100 then fuel += 0.1 end
					end
				end)
			end)
			tool.Unequipped:Connect(function() flying = false; bv.MaxForce = Vector3.new(0,0,0) end)
		]]
		tool.Parent = player.Backpack
	end
end

-- UPGRADE MOCHILA (REMOTE FUNCTION)
upgradeInvEvent.OnServerInvoke = function(player)
	local currentSlots = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS
	
	-- FASE 1: CASH (Hasta 16)
	if currentSlots < SETTINGS.CASH_SLOT_LIMIT then
		local cost = 1000 * (currentSlots ^ 2)
		if player.leaderstats.Cash.Value >= cost then
			player.leaderstats.Cash.Value -= cost
			local newSlots = currentSlots + 4
			player:SetAttribute("MaxSlots", newSlots)
			return true, "¬°Mochila mejorada a " .. newSlots .. " slots!"
		else
			return false, "Necesitas $" .. cost .. " para mejorar."
		end
	-- FASE 2: ROBUX (Hasta 32)
	elseif currentSlots < SETTINGS.MAX_TOTAL_SLOTS then
		MarketplaceService:PromptProductPurchase(player, SETTINGS.DEV_PRODUCT_SLOTS_ID)
		return true, "Abriendo mercado de Robux..."
	else
		return false, "¬°Mochila al M√ÅXIMO nivel!"
	end
end

-- PROCESS RECEIPT (COMPRAS REALES)
MarketplaceService.ProcessReceipt = function(receiptInfo)
	local player = Players:GetPlayerByUserId(receiptInfo.PlayerId)
	if not player then return Enum.ProductPurchaseDecision.NotProcessedYet end
	
	-- COMPRA DE SLOTS
	if receiptInfo.ProductId == SETTINGS.DEV_PRODUCT_SLOTS_ID then
		local current = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS
		if current < SETTINGS.MAX_TOTAL_SLOTS then
			player:SetAttribute("MaxSlots", current + 4)
			eventMessage:FireClient(player, "üíé ¬°Espacio aumentado con Robux!")
			return Enum.ProductPurchaseDecision.PurchaseGranted
		end
	end
	
	-- COMPRA DE PERMABLOCK
	if receiptInfo.ProductId == SETTINGS.DEV_PRODUCT_PERMABLOCK_ID then
		local tycoon = towersFolder:FindFirstChild("Tycoon_"..player.UserId)
		if tycoon then
			local data = {Name = "Permablock", Value = 200, Price = 0, Rarity = "ETERNO", Color = Color3.new(1,1,1), Mat = Enum.Material.Neon}
			-- Crear cubo y forzarlo a la mano
			local cube = Instance.new("Part"); cube.Name = data.Name; cube.Size = Vector3.new(4,4,4)
			cube.Material = data.Mat; cube.Color = data.Color
			cube:SetAttribute("Owner", player.UserId); cube:SetAttribute("Value", 200); cube:SetAttribute("IsPerma", true)
			
			-- Pickup forzado
			player:SetAttribute("Carrying", true); player:SetAttribute("CarryingValue", 200)
			cube.CanCollide = false; cube.Anchored = false; cube.Parent = player.Character
			local w = Instance.new("WeldConstraint", cube); w.Part0 = player.Character.HumanoidRootPart; w.Part1 = cube
			cube.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 5)
			
			return Enum.ProductPurchaseDecision.PurchaseGranted
		end
	end
	
	return Enum.ProductPurchaseDecision.NotProcessedYet
end

-- ==========================================================
-- 3. L√ìGICA DE INVENTARIO Y RECOGIDA
-- ==========================================================

function PickupCube(player, cube, val)
	-- A. Si manos vac√≠as -> Equipar
	if not player:GetAttribute("Carrying") then
		player:SetAttribute("Carrying", true)
		player:SetAttribute("CarryingValue", val)
		
		cube.CanCollide = false
		cube.Anchored = false
		cube.Parent = player.Character
		local w = Instance.new("WeldConstraint", cube)
		w.Name = "CarryingWeld"
		w.Part0 = player.Character.HumanoidRootPart
		w.Part1 = cube
		cube.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 5) 
	else
		-- B. Si manos llenas -> Intentar Mochila
		local inv = player:FindFirstChild("Inventory")
		local maxSlots = player:GetAttribute("MaxSlots") or SETTINGS.BASE_SLOTS
		
		if inv and #inv:GetChildren() < maxSlots then
			cube.CanCollide = false
			cube.Anchored = true
			cube.Transparency = 1 -- Ocultar
			cube.CFrame = CFrame.new(0, -500, 0)
			cube.Parent = inv
			cube:SetAttribute("Owner", player.UserId)
			eventMessage:FireClient(player, "üéí Guardado: " .. cube.Name)
		else
			eventMessage:FireClient(player, "‚ùå ¬°Mochila Llena!")
		end
	end
end

-- Sacar item de mochila
equipInvEvent.OnServerEvent:Connect(function(player)
	if player:GetAttribute("Carrying") then return end
	local inv = player:FindFirstChild("Inventory")
	if inv and #inv:GetChildren() > 0 then
		local items = inv:GetChildren()
		local cube = items[#items] -- Sacar el √∫ltimo
		
		cube.Transparency = 0
		cube.Anchored = false
		
		player:SetAttribute("Carrying", true)
		player:SetAttribute("CarryingValue", cube:GetAttribute("Value"))
		
		cube.Parent = player.Character
		local w = Instance.new("WeldConstraint", cube)
		w.Name = "CarryingWeld"
		w.Part0 = player.Character.HumanoidRootPart
		w.Part1 = cube
		cube.CFrame = player.Character.HumanoidRootPart.CFrame * CFrame.new(0, 0, 5)
		
		eventMessage:FireClient(player, "üîº Equipado: " .. cube.Name)
	end
end)

-- ==========================================================
-- 4. SPAWN DE CUBOS Y MEC√ÅNICAS (SPYBOX, GLITCH...)
-- ==========================================================

function CreateStealPrompt(cube)
	if cube:FindFirstChild("StealPrompt") then return end
	local price = cube:GetAttribute("Price") or 100
	local originalOwnerId = cube:GetAttribute("Owner")
	
	local p = Instance.new("ProximityPrompt", cube)
	p.Name = "StealPrompt"; p.ActionText = "ROBAR/RECUPERAR"; p.HoldDuration = 1
	
	p.Triggered:Connect(function(interactor)
		local cost = price * 3
		if interactor.UserId == originalOwnerId then cost = 0 end -- Gratis si es tuyo
		
		if interactor.leaderstats.Cash.Value >= cost then
			interactor.leaderstats.Cash.Value -= cost
			p:Destroy() 
			-- Romper welds y soltar
			for _, w in ipairs(cube:GetChildren()) do if w:IsA("WeldConstraint") then w:Destroy() end end
			cube.Anchored = false
			PickupCube(interactor, cube, cube:GetAttribute("Value"))
		end
	end)
end

function SpawnCube(customData)
	if #globalCubes:GetChildren() >= 80 then return end
	local data = customData or CUBE_TYPES[math.random(1, #CUBE_TYPES)]
	
	local cube = Instance.new("Part")
	cube.Name = data.Name
	cube.Size = Vector3.new(4,4,4)
	
	if data.Name == "Jab√≥n" then 
		cube.Shape = Enum.PartType.Ball 
		cube.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0, 0.5, 100, 1) 
	end

	cube.Position = Vector3.new(math.random(-60, 60), 120, math.random(-60, 60))
	cube.Material, cube.Color = data.Mat, data.Color
	cube:SetAttribute("Owner", 0); cube:SetAttribute("Value", data.Value); cube:SetAttribute("Price", data.Price)

	if data.Name == "Permablock" then cube:SetAttribute("IsPerma", true) end

	if data.Name == "Glitch" then
		task.spawn(function()
			while cube and cube.Parent do
				local newVal = math.random(-100, 500)
				cube:SetAttribute("Value", newVal)
				task.wait(10)
			end
		end)
	end

	if data.Name == "Antimateria" then
		cube.Touched:Connect(function(hit)
			if hit:IsA("BasePart") and hit ~= cube then
				if hit:GetAttribute("IsPerma") then return end
				local isOtherCube = hit:GetAttribute("Value") ~= nil or (hit.Parent and (hit.Parent.Name == "Blocks" or hit.Parent.Name == "GlobalCubes"))
				if isOtherCube then
					local exp = Instance.new("Explosion"); exp.Position = cube.Position; exp.BlastRadius = 6; exp.Parent = workspace
					hit:Destroy(); cube:Destroy()
				end
			end
		end)
	end

	-- ETIQUETAS VISUALES
	local function makeTxt(face, txt, color)
		local sg = Instance.new("SurfaceGui", cube); sg.Face = face
		local t = Instance.new("TextLabel", sg); t.Size = UDim2.new(1,0,1,0); t.Text = txt; t.TextScaled = true; t.TextColor3 = color; t.BackgroundTransparency = 1; t.Font = Enum.Font.FredokaOne
		return t
	end
	makeTxt(Enum.NormalId.Front, data.Rarity.."\n"..data.Name, Color3.new(1,1,1))
	
	local valLabel = makeTxt(Enum.NormalId.Top, "", Color3.new(0,1,0))
	task.spawn(function()
		while cube and cube.Parent do
			local currentVal = cube:GetAttribute("Value") or 0
			valLabel.Text = (currentVal >= 0 and "+$" or "$")..currentVal.."/s"
			valLabel.TextColor3 = currentVal >= 0 and Color3.new(0,1,0) or Color3.new(1,0,0)
			task.wait(1)
		end
	end)

	local timerLabel = makeTxt(Enum.NormalId.Right, SETTINGS.CUBE_LIFETIME.."s", Color3.new(1,1,0))

	task.spawn(function()
		task.wait(0.2)
		for i = SETTINGS.CUBE_LIFETIME, 0, -1 do
			if not cube or not cube.Parent or (cube:GetAttribute("Owner") or 0) ~= 0 then 
				if timerLabel and timerLabel.Parent then 
					local ownerId = cube:GetAttribute("Owner")
					local n = "ADQUIRIDO"
					local p = Players:GetPlayerByUserId(ownerId); if p then n = p.Name end
					timerLabel.Text = n; timerLabel.TextColor3 = Color3.new(0,1,0)
				end
				return 
			end
			timerLabel.Text = i .. "s"; task.wait(1)
		end
		if cube and cube.Parent and (cube:GetAttribute("Owner") or 0) == 0 then cube:Destroy() end
	end)

	local prompt = Instance.new("ProximityPrompt", cube); prompt.HoldDuration = 0.1
	prompt.ActionText = data.Price > 0 and ("COMPRAR $"..data.Price) or "RECOGER"; cube.Parent = globalCubes
	
	prompt.Triggered:Connect(function(player)
		local owner = cube:GetAttribute("Owner") or 0
		local cost = (owner == 0) and data.Price or (owner == player.UserId and 0 or (data.Price == 0 and 200 or data.Price * 6))
		if owner == player.UserId then cost = 0 end 
		
		if player.leaderstats.Cash.Value >= cost then
			player.leaderstats.Cash.Value -= cost
			cube:SetAttribute("Owner", player.UserId)
			prompt.Enabled = false
			PickupCube(player, cube, data.Value)
		end
	end)
	return cube
end

-- ==========================================================
-- 5. EVENTO PRINCIPAL: COLOCAR CUBOS (PLACE)
-- ==========================================================

placeEvent.OnServerEvent:Connect(function(player, hitPos)
	local char = player.Character; if not char then return end
	
	-- 1. Intentar sacar de mano
	local carriedCube = nil
	for _, child in ipairs(char:GetChildren()) do 
		if child:IsA("Part") and child:FindFirstChild("CarryingWeld") then carriedCube = child; break end 
	end
	
	-- 2. Si no hay en mano, sacar de mochila
	if not carriedCube then
		local inv = player:FindFirstChild("Inventory")
		if inv and #inv:GetChildren() > 0 then
			local items = inv:GetChildren(); local cube = items[#items]
			cube.Transparency = 0; cube.Anchored = false
			player:SetAttribute("Carrying", true); player:SetAttribute("CarryingValue", cube:GetAttribute("Value"))
			cube.Parent = player.Character
			local w = Instance.new("WeldConstraint", cube); w.Name="CarryingWeld"; w.Part0=char.HumanoidRootPart; w.Part1=cube; cube.CFrame=char.HumanoidRootPart.CFrame*CFrame.new(0,0,5)
			carriedCube = cube
		else
			return -- Nada en mano ni mochila
		end
	end

	local weld = carriedCube:FindFirstChild("CarryingWeld"); if weld then weld:Destroy() end
	player:SetAttribute("Carrying", false)
	carriedCube.CanCollide = true; carriedCube.Anchored = false; carriedCube.AssemblyLinearVelocity = Vector3.new(0,0,0) 

	local targetPlot = nil
	for _, plotModel in ipairs(towersFolder:GetChildren()) do
		local originPart = plotModel:FindFirstChild("GridParts") and plotModel.GridParts:FindFirstChild("Origin")
		if originPart then
			local dist = (Vector2.new(hitPos.X, hitPos.Z) - Vector2.new(originPart.Position.X, originPart.Position.Z)).Magnitude
			if dist < 160 then targetPlot = plotModel; break end
		end
	end

	if targetPlot then
		local origin = targetPlot.GridParts.Origin.Position
		local gx, gz = math.round((hitPos.X-origin.X)/4)*4 + origin.X, math.round((hitPos.Z-origin.Z)/4)*4 + origin.Z
		
		local rayParams = RaycastParams.new()
		rayParams.FilterDescendantsInstances = {char, carriedCube}
		rayParams.FilterType = Enum.RaycastFilterType.Exclude
		local ray = workspace:Raycast(Vector3.new(gx, 500, gz), Vector3.new(0, -500, 0), rayParams)
		
		if ray then 
			carriedCube.Position = Vector3.new(gx, ray.Position.Y + 2.1, gz) 
			local blks = targetPlot:FindFirstChild("Blocks") or Instance.new("Folder", targetPlot); blks.Name = "Blocks"
			carriedCube.Parent = blks
			
			if ray.Instance.Name == "Origin" then
				carriedCube.Anchored = true
			else
				carriedCube.Anchored = false
				local newWeld = Instance.new("WeldConstraint")
				newWeld.Part0 = ray.Instance; newWeld.Part1 = carriedCube; newWeld.Parent = carriedCube
				carriedCube.Massless = true 
			end

			local plotOwnerID = targetPlot:GetAttribute("OwnerID")
			if plotOwnerID and plotOwnerID ~= player.UserId then 
				CreateStealPrompt(carriedCube) 
			end
		else 
			carriedCube.Position = Vector3.new(gx, 4, gz) 
			carriedCube.Parent = globalCubes 
			carriedCube.Anchored = false
		end
	else
		carriedCube.CFrame = char.HumanoidRootPart.CFrame * CFrame.new(0, 0, -8)
		carriedCube.Parent = globalCubes
	end
	if carriedCube:FindFirstChild("ProximityPrompt") then carriedCube.ProximityPrompt.Enabled = true end
end)

-- ==========================================================
-- 6. BASES, ANDAMIOS Y SETUP
-- ==========================================================

function SetupPlots()
	local angleStep = (math.pi * 2) / SETTINGS.MAX_PLAYERS
	for i = 1, SETTINGS.MAX_PLAYERS do
		local angle = (i-1) * angleStep
		local pos = Vector3.new(math.sin(angle) * SETTINGS.CENTER_DIST, 1, math.cos(angle) * SETTINGS.CENTER_DIST)
		
		local m = Instance.new("Model", towersFolder); m.Name = "Plot_"..i
		local gp = Instance.new("Folder", m); gp.Name = "GridParts"
		local base = Instance.new("Part", gp); base.Name = "Origin"; base.Size = Vector3.new(32,1,32); base.Position = pos; base.Anchored = true; base.Material = Enum.Material.DiamondPlate
		base.CFrame = CFrame.lookAt(pos, Vector3.new(0, 1, 0))
		m:SetAttribute("OwnerID", 0); m:SetAttribute("Expansions", 0)

		local board = Instance.new("Part", m); board.Size = Vector3.new(18,12,1); board.Anchored = true; board.Name = "Board"; board.Color = Color3.new(0,0,0)
		local btn = Instance.new("Part", m); btn.Name = "ExpandButton"; btn.Size = Vector3.new(8, 1, 8); btn.Anchored = true; btn.Color = Color3.fromRGB(0, 150, 255); btn.Material = Enum.Material.Neon
		local rec = Instance.new("Part", m); rec.Name = "Recycler"; rec.Size = Vector3.new(12, 0.5, 12); rec.Anchored = true; rec.Color = Color3.fromRGB(255, 0, 0); rec.Material = Enum.Material.Neon

		-- Andamio
		m:SetAttribute("ScaffoldHeight", 0)
		local sbtn = Instance.new("Part", m); sbtn.Name = "ScaffoldButton"; sbtn.Size = Vector3.new(6, 1, 6); sbtn.Anchored = true; sbtn.Color = Color3.fromRGB(255, 200, 0); sbtn.Material = Enum.Material.Neon

		local function updateAssets()
			board.CFrame = base.CFrame * CFrame.new(0, 10, (base.Size.Z/2) + 8)
			btn.CFrame = base.CFrame * CFrame.new(0, 0, (base.Size.Z/2) + 16)
			rec.CFrame = base.CFrame * CFrame.new(-(base.Size.X/2 + 10), 0, 0)
			sbtn.CFrame = base.CFrame * CFrame.new(12, 0, (base.Size.Z/2) + 12)
		end
		updateAssets()

		local bp = Instance.new("ProximityPrompt", btn); bp.ActionText = "EXPANDIR ($"..SETTINGS.BASE_EXPAND_COST..")"; bp.HoldDuration = 1
		bp.Triggered:Connect(function(plr)
			local count = m:GetAttribute("Expansions")
			if plr.UserId == m:GetAttribute("OwnerID") and count < SETTINGS.MAX_EXPANSIONS and plr.leaderstats.Cash.Value >= SETTINGS.BASE_EXPAND_COST then
				plr.leaderstats.Cash.Value -= SETTINGS.BASE_EXPAND_COST
				m:SetAttribute("Expansions", count + 1); base.Size += Vector3.new(12, 0, 12); updateAssets()
				if count + 1 >= SETTINGS.MAX_EXPANSIONS then bp.Enabled = false; btn.Transparency = 0.5 end
			end
		end)

		local rp = Instance.new("ProximityPrompt", rec); rp.HoldDuration = 0.2
		rp.Triggered:Connect(function(plr)
			if plr.UserId == m:GetAttribute("OwnerID") then
				local cube = nil
				for _, c in ipairs(plr.Character:GetChildren()) do if c:IsA("Part") and c:FindFirstChild("CarryingWeld") then cube = c; break end end
				if cube then
					if cube:GetAttribute("IsPerma") then return end
					local val = cube:GetAttribute("Value") or 0
					plr.leaderstats.Cash.Value += math.max(0, math.floor(val * 30)); cube:Destroy(); plr:SetAttribute("Carrying", false)
				end
			end
		end)

		local sp = Instance.new("ProximityPrompt", sbtn); sp.ActionText = "ANDAMIO ($1B)"; sp.HoldDuration = 2
		sp.Triggered:Connect(function(plr)
			if plr.UserId == m:GetAttribute("OwnerID") and plr.leaderstats.Cash.Value >= SETTINGS.SCAFFOLD_COST then
				plr.leaderstats.Cash.Value -= SETTINGS.SCAFFOLD_COST
				local currentH = m:GetAttribute("ScaffoldHeight")
				local scaffold = Instance.new("TrussPart", m); scaffold.Name = "Scaffold"; scaffold.Size = Vector3.new(2, 40, 2); scaffold.Anchored = true
				scaffold.Position = base.Position + Vector3.new(base.Size.X/2 + 4, 20 + currentH, 0); scaffold.Color = Color3.new(0.5,0.5,0.5)
				m:SetAttribute("ScaffoldHeight", currentH + 40)
			end
		end)

		for _, f in ipairs({Enum.NormalId.Front, Enum.NormalId.Back}) do
			local sg = Instance.new("SurfaceGui", board); sg.Face = f
			local t = Instance.new("TextLabel", sg); t.Size = UDim2.new(1,0,1,0); t.Text = "DISPONIBLE"; t.TextScaled = true; t.TextColor3 = Color3.new(1,1,1); t.BackgroundTransparency = 1; t.Font = Enum.Font.FredokaOne
		end
		plots[i] = {Model = m, Owner = nil}
	end
end

-- ==========================================================
-- 7. LOOPS MAESTROS (ECONOM√çA, MERCADO, EVENTOS)
-- ==========================================================

-- LOOP ECONOM√çA
task.spawn(function()
	while true do
		task.wait(SETTINGS.PAY_INTERVAL)
		for _, p in ipairs(Players:GetPlayers()) do
			local t = towersFolder:FindFirstChild("Tycoon_"..p.UserId)
			if t then
				local inc, maxH = 0, 0; local origin = t.GridParts.Origin.Position
				local blks = t:FindFirstChild("Blocks") or Instance.new("Folder", t); blks.Name = "Blocks"
				for _, b in ipairs(blks:GetChildren()) do
					if (Vector2.new(b.Position.X, b.Position.Z) - Vector2.new(origin.X, origin.Z)).Magnitude < 240 then
						-- APLICACI√ìN DEL MERCADO
						local baseVal = b:GetAttribute("Value") or 0
						local m = MarketMultipliers[b.Name] or 1.0
						inc += (baseVal * m)
						
						local h = b.Position.Y - origin.Y; if h > maxH then maxH = h end
					else b.Parent = globalCubes; b.Anchored = false end
				end
				local mult = 1 + (math.floor(maxH/4)*0.5); local totalTick = inc * mult
				p.leaderstats.Cash.Value = math.max(0, p.leaderstats.Cash.Value + totalTick)
				p:SetAttribute("MaxH", maxH); p:SetAttribute("Time", (p:GetAttribute("Time") or 0) + 1)
				
				for _, sg in ipairs(t.Board:GetChildren()) do if sg:IsA("SurfaceGui") then sg.TextLabel.Text = string.format("%s\n$%.1f/s\n%dft (x%.1f)", p.Name, inc*mult, maxH, mult) end end
			end
		end
	end
end)

-- LOOP MERCADO (STONKS)
task.spawn(function()
	while true do
		task.wait(60) -- 60s
		local targetData = CUBE_TYPES[math.random(1, #CUBE_TYPES)]; local targetName = targetData.Name
		local rawMult = math.random(5, 30) / 10 -- 0.5x a 3.0x
		
		for k, _ in pairs(MarketMultipliers) do MarketMultipliers[k] = 1.0 end -- Reset
		MarketMultipliers[targetName] = rawMult
		
		local status = (rawMult > 1) and "üìà BOOM" or (rawMult < 1 and "üìâ CRASH" or "Estable")
		local msg = string.format("%s: %s x%.1f", status, targetName, rawMult)
		MarketNews.Value = msg; eventMessage:FireAllClients(msg)
	end
end)

-- LOOP EVENTOS
task.spawn(function()
	local chaosTimer, celestialTimer, stormTimer = 0, 0, 0
	while true do
		task.wait(1); chaosTimer += 1; celestialTimer += 1; stormTimer += 1
		
		if chaosTimer >= SETTINGS.CHAOS_INTERVAL then 
			chaosTimer = 0; local e = math.random(1,3)
			if e == 1 then eventMessage:FireAllClients("‚ö† ¬°FALLO GRAVEDAD! ‚ö†"); workspace.Gravity = 30; task.wait(45); workspace.Gravity = 196.2
			elseif e == 2 then eventMessage:FireAllClients("‚ö† ¬°SPEED RUN! ‚ö†"); for _,p in ipairs(Players:GetPlayers()) do if p.Character then p.Character.Humanoid.WalkSpeed = 80 end end; task.wait(30); for _,p in ipairs(Players:GetPlayers()) do if p.Character then p.Character.Humanoid.WalkSpeed = SETTINGS.PLAYER_SPEED end end
			elseif e == 3 then eventMessage:FireAllClients("‚ö† ¬°EL JUICIO DEL YUNQUE! ‚ö†"); task.wait(4); local rich, maxC = nil, -1; for _,p in ipairs(Players:GetPlayers()) do if p.leaderstats.Cash.Value > maxC then maxC = p.leaderstats.Cash.Value; rich = p end end; if rich and rich.Character then local anvil = Instance.new("Part"); anvil.Size = Vector3.new(12,10,12); anvil.Color = Color3.new(0,0,0); anvil.Position = rich.Character.HumanoidRootPart.Position + Vector3.new(0,100,0); anvil.CustomPhysicalProperties = PhysicalProperties.new(100, 0, 0, 100, 100); anvil.Parent = workspace; Debris:AddItem(anvil, 20) end
			end
		end

		if celestialTimer >= (SETTINGS.CELESTIAL_INTERVAL - 20) then
			celestialTimer = 0; local top, maxH = nil, -1
			for _,p in ipairs(Players:GetPlayers()) do local h = p:GetAttribute("MaxH") or 0; if h > maxH then maxH = h; top = p end end
			if top and maxH > 0 then
				if top.Character then local ff = Instance.new("ForceField", top.Character); Debris:AddItem(ff, 60) end
				eventMessage:FireAllClients("‚ú® TRIBUTO PARA "..top.Name.." ‚ú®")
				local t = towersFolder:FindFirstChild("Tycoon_"..top.UserId)
				if t then local ac = SpawnCube({Name="APEX", Value=1000, Price=0, Rarity="GOD", Color=Color3.new(1,1,1), Mat=Enum.Material.Neon}); ac.Anchored=true; ac.Position = t.GridParts.Origin.Position + Vector3.new(0, maxH+10, 0); ac.Parent = t.Blocks end
			end
		end
		
		if stormTimer >= 900 then
			stormTimer = 0; local topGlobalCube, topGlobalY = nil, -1e9
			for _, tycoon in ipairs(towersFolder:GetChildren()) do
				local blks = tycoon:FindFirstChild("Blocks")
				if blks then
					for _, b in ipairs(blks:GetChildren()) do
						if b:IsA("Part") and b.Position.Y > topGlobalY and (b.Material == Enum.Material.Metal or b.Material == Enum.Material.DiamondPlate) then topGlobalY = b.Position.Y; topGlobalCube = b end
					end
				end
			end
			if topGlobalCube then
				local msg = Instance.new("Message", workspace); msg.Text = "‚ö° RAYO DE ZEUS ‚ö°"; Debris:AddItem(msg, 10)
				local beam = Instance.new("Part", workspace); beam.Size = Vector3.new(2, 500, 2); beam.Position = topGlobalCube.Position + Vector3.new(0, 250, 0); beam.Anchored = true; beam.CanCollide = false; beam.Color = Color3.new(1,1,1); beam.Material = Enum.Material.Neon; Debris:AddItem(beam, 0.5)
				topGlobalCube:SetAttribute("Value", (topGlobalCube:GetAttribute("Value") or 0) * 8); topGlobalCube.Color = Color3.fromRGB(0, 255, 255)
			end
		end
	end
end)

-- ==========================================================
-- 8. INICIALIZACI√ìN Y PLAYER LIFECYCLE
-- ==========================================================
SetupPlots()

Players.PlayerAdded:Connect(function(p)
	local ls = Instance.new("Folder", p); ls.Name = "leaderstats"
	local cash = Instance.new("NumberValue", ls); cash.Name = "Cash"; cash.Value = 1200
	local inv = Instance.new("Folder", p); inv.Name = "Inventory"
	p:SetAttribute("MaxSlots", SETTINGS.BASE_SLOTS); p:SetAttribute("Carrying", false); p:SetAttribute("Time", 0); p:SetAttribute("MaxH", 0)
	
	LoadPlayerData(p) -- CARGAR DATOS

	p.CharacterAdded:Connect(function(char)
		task.wait(0.5); local hum = char:WaitForChild("Humanoid"); local hrp = char:WaitForChild("HumanoidRootPart")
		hum.WalkSpeed = SETTINGS.PLAYER_SPEED; hum.Died:Connect(function() p:SetAttribute("Carrying", false) end)
		GiveJetpack(p)
		
		local tb = false
		hrp.Touched:Connect(function(hit)
			if tb then return end
			local enemy = hit.Parent; local ePlr = Players:GetPlayerFromCharacter(enemy)
			if ePlr and ePlr ~= p and hrp.AssemblyLinearVelocity.Magnitude > SETTINGS.TACKLE_SPEED_THRESHOLD and ePlr:GetAttribute("Carrying") then
				tb = true
				local cc = nil
				for _,c in ipairs(enemy:GetChildren()) do if c:FindFirstChild("CarryingWeld") then cc = c; break end end
				if cc then
					if cc:GetAttribute("IsPerma") then tb=false; return end
					cc:FindFirstChild("CarryingWeld"):Destroy(); ePlr:SetAttribute("Carrying", false); cc.CanCollide = true; cc.Anchored = false; cc.Parent = globalCubes
					local force = (enemy.HumanoidRootPart.Position - hrp.Position).Unit
					cc:ApplyImpulse(force * 1500 + Vector3.new(0,800,0)); task.wait(3); tb = false
				end
			end
		end)
	end)
	
	for _, plot in ipairs(plots) do if not plot.Owner then plot.Owner = p; plot.Model.Name = "Tycoon_"..p.UserId; plot.Model:SetAttribute("OwnerID", p.UserId); break end end
end)

Players.PlayerRemoving:Connect(function(p) SavePlayerData(p) end)
game:BindToClose(function() for _, p in ipairs(Players:GetPlayers()) do SavePlayerData(p) end end)

task.spawn(function() while true do task.wait(1.5) SpawnCube() end end)
